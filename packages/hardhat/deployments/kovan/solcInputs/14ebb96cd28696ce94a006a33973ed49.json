{
  "language": "Solidity",
  "sources": {
    "contracts/core/interfaces/IACLRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IACLRegistry {\n  /**\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n   *\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n   * {RoleAdminChanged} not being emitted signaling this.\n   *\n   * _Available since v3.1._\n   */\n  event RoleAdminChanged(\n    bytes32 indexed role,\n    bytes32 indexed previousAdminRole,\n    bytes32 indexed newAdminRole\n  );\n\n  /**\n   * @dev Emitted when `account` is granted `role`.\n   *\n   * `sender` is the account that originated the contract call, an admin role\n   * bearer except when using {AccessControl-_setupRole}.\n   */\n  event RoleGranted(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Emitted when `account` is revoked `role`.\n   *\n   * `sender` is the account that originated the contract call:\n   *   - if using `revokeRole`, it is the admin role bearer\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n   */\n  event RoleRevoked(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  /**\n   * @dev Returns `true` if `account` has been granted `permission`.\n   */\n  function hasPermission(bytes32 permission, address account)\n    external\n    view\n    returns (bool);\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) external;\n\n  function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n\n  function grantPermission(bytes32 permission, address account) external;\n\n  function revokePermission(bytes32 permission) external;\n\n  function requireApprovedContractOrEOA(address account) external view;\n\n  function requireRole(bytes32 role, address account) external view;\n\n  function requirePermission(bytes32 permission, address account) external view;\n\n  function isRoleAdmin(bytes32 role, address account) external view;\n}\n"
    },
    "contracts/test_helpers/ACLRegistryHelper.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"../core/interfaces/IACLRegistry.sol\";\n\ncontract ACLRegistryHelper {\n  IACLRegistry public aclRegistry;\n\n  constructor(IACLRegistry _aclRegistry) {\n    aclRegistry = _aclRegistry;\n  }\n\n  function senderProtected(bytes32 role) public {\n    require(\n      aclRegistry.hasRole(role, msg.sender),\n      \"you dont have the required role\"\n    );\n  }\n}\n"
    },
    "contracts/core/utils/ContractRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../interfaces/IACLRegistry.sol\";\nimport \"../interfaces/IContractRegistry.sol\";\n\n/**\n * @dev This Contract holds reference to all our contracts. Every contract A that needs to interact with another contract B calls this contract\n * to ask for the address of B.\n * This allows us to update addresses in one central point and reduces constructing and management overhead.\n */\ncontract ContractRegistry is IContractRegistry {\n  struct Contract {\n    address contractAddress;\n    bytes32 version;\n  }\n\n  /* ========== STATE VARIABLES ========== */\n\n  IACLRegistry public aclRegistry;\n\n  mapping(bytes32 => Contract) public contracts;\n  bytes32[] public contractNames;\n\n  /* ========== EVENTS ========== */\n\n  event ContractAdded(bytes32 _name, address _address, bytes32 _version);\n  event ContractUpdated(bytes32 _name, address _address, bytes32 _version);\n  event ContractDeleted(bytes32 _name);\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(IACLRegistry _aclRegistry) {\n    aclRegistry = _aclRegistry;\n    contracts[keccak256(\"ACLRegistry\")] = Contract({\n      contractAddress: address(_aclRegistry),\n      version: keccak256(\"1\")\n    });\n    contractNames.push(keccak256(\"ACLRegistry\"));\n  }\n\n  /* ========== VIEW FUNCTIONS ========== */\n\n  function getContractNames() external view returns (bytes32[] memory) {\n    return contractNames;\n  }\n\n  function getContract(bytes32 _name) external view override returns (address) {\n    return contracts[_name].contractAddress;\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function addContract(\n    bytes32 _name,\n    address _address,\n    bytes32 _version\n  ) external {\n    aclRegistry.requireRole(keccak256(\"DAO\"), msg.sender);\n    require(\n      contracts[_name].contractAddress == address(0),\n      \"contract already exists\"\n    );\n    contracts[_name] = Contract({contractAddress: _address, version: _version});\n    contractNames.push(_name);\n    emit ContractAdded(_name, _address, _version);\n  }\n\n  function updateContract(\n    bytes32 _name,\n    address _newAddress,\n    bytes32 _version\n  ) external {\n    aclRegistry.requireRole(keccak256(\"DAO\"), msg.sender);\n    require(\n      contracts[_name].contractAddress != address(0),\n      \"contract doesnt exist\"\n    );\n    contracts[_name] = Contract({\n      contractAddress: _newAddress,\n      version: _version\n    });\n    emit ContractUpdated(_name, _newAddress, _version);\n  }\n\n  function deleteContract(bytes32 _name, uint256 _contractIndex) external {\n    aclRegistry.requireRole(keccak256(\"DAO\"), msg.sender);\n    require(\n      contracts[_name].contractAddress != address(0),\n      \"contract doesnt exist\"\n    );\n    require(\n      contractNames[_contractIndex] == _name,\n      \"this is not the contract you are looking for\"\n    );\n    delete contracts[_name];\n    delete contractNames[_contractIndex];\n    emit ContractDeleted(_name);\n  }\n}\n"
    },
    "contracts/core/interfaces/IContractRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev External interface of ContractRegistry.\n */\ninterface IContractRegistry {\n  function getContract(bytes32 _name) external view returns (address);\n}\n"
    },
    "contracts/core/utils/ACLRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../interfaces/IACLRegistry.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\ncontract ACLRegistry is IACLRegistry {\n  /* ========== STATE VARIABLES ========== */\n\n  struct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n  }\n\n  mapping(bytes32 => RoleData) private _roles;\n  mapping(bytes32 => address) private _permissions;\n\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor() {\n    _roles[DEFAULT_ADMIN_ROLE].members[msg.sender] = true;\n  }\n\n  /* ========== VIEW FUNCTIONS ========== */\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account)\n    public\n    view\n    override\n    returns (bool)\n  {\n    return _roles[role].members[account];\n  }\n\n  /**\n   * @dev Returns `true` if `account` has been granted `permission`.\n   */\n  function hasPermission(bytes32 permission, address account)\n    public\n    view\n    override\n    returns (bool)\n  {\n    return _permissions[permission] == account;\n  }\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n    return _roles[role].adminRole;\n  }\n\n  function requireRole(bytes32 role, address account) public view override {\n    require(hasRole(role, account), \"you dont have the right role\");\n  }\n\n  function requirePermission(bytes32 permission, address account)\n    public\n    view\n    override\n  {\n    require(\n      hasPermission(permission, account),\n      \"you dont have the right permissions\"\n    );\n  }\n\n  function isRoleAdmin(bytes32 role, address account) public view override {\n    require(hasRole(getRoleAdmin(role), account), \"you have to be role admin\");\n  }\n\n  function requireApprovedContractOrEOA(address account) public view override {\n    require(\n      hasRole(keccak256(\"ApprovedContract\"), account) || account == tx.origin,\n      \"Access denied for caller\"\n    );\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account)\n    public\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account)\n    public\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) public override {\n    require(\n      account == msg.sender || hasRole(getRoleAdmin(role), msg.sender),\n      \"you cant renounce this role\"\n    );\n\n    _revokeRole(role, account);\n  }\n\n  function setRoleAdmin(bytes32 role, bytes32 adminRole) public override {\n    require(\n      hasRole(getRoleAdmin(role), msg.sender) ||\n        hasRole(DEFAULT_ADMIN_ROLE, msg.sender),\n      \"can only renounce roles for self\"\n    );\n\n    _setRoleAdmin(role, adminRole);\n  }\n\n  function grantPermission(bytes32 permission, address account)\n    public\n    override\n  {\n    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"only for admin\");\n    _permissions[permission] = account;\n  }\n\n  function revokePermission(bytes32 permission) public override {\n    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"only for admin\");\n    delete _permissions[permission];\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /**\n   * @dev Revert with a standard message if `account` is missing `role`.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   */\n  function _requireRole(bytes32 role, address account) internal view {\n    require(hasRole(role, account), \"you dont have the required role\");\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event. Note that unlike {grantRole}, this function doesn't perform any\n   * checks on the calling account.\n   *\n   * [WARNING]\n   * ====\n   * This function should only be called from the constructor when setting\n   * up the initial roles for the system.\n   *\n   * Using this function in any other way is effectively circumventing the admin\n   * system imposed by {AccessControl}.\n   * ====\n   */\n  function _setupRole(bytes32 role, address account) internal {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Sets `adminRole` as ``role``'s admin role.\n   *\n   * Emits a {RoleAdminChanged} event.\n   */\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n    bytes32 previousAdminRole = getRoleAdmin(role);\n    _roles[role].adminRole = adminRole;\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\n  }\n\n  function _grantRole(bytes32 role, address account) private {\n    if (!hasRole(role, account)) {\n      _roles[role].members[account] = true;\n      emit RoleGranted(role, account, msg.sender);\n    }\n  }\n\n  function _revokeRole(bytes32 role, address account) private {\n    if (hasRole(role, account)) {\n      _roles[role].members[account] = false;\n      emit RoleRevoked(role, account, msg.sender);\n    }\n  }\n\n  /* ========== MODIFIER ========== */\n\n  /**\n   * @dev Modifier that checks that an account has a specific role. Reverts\n   * with a standardized message including the required role.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   *\n   * _Available since v4.1._\n   */\n  modifier onlyRole(bytes32 role) {\n    _requireRole(role, msg.sender);\n    _;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
