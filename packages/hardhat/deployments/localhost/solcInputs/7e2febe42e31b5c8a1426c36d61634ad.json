{
  "language": "Solidity",
  "sources": {
    "contracts/core/dao/LockStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Docgen-SOLC: 0.8.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"../interfaces/IStaking.sol\";\nimport \"../interfaces/IRewardsManager.sol\";\nimport \"../interfaces/IRewardsEscrow.sol\";\n\ncontract LockStaking is IStaking, Ownable, ReentrancyGuard, Pausable {\n  using SafeERC20 for IERC20;\n\n  struct LockedBalance {\n    uint256 balance;\n    uint256 end;\n  }\n\n  /* ========== STATE VARIABLES ========== */\n\n  IERC20 public immutable token;\n  IRewardsEscrow public rewardsEscrow;\n\n  uint256 public periodFinish = 0;\n  uint256 public rewardRate = 0;\n  uint256 public rewardsDuration = 7 days;\n  uint256 public lastUpdateTime;\n  uint256 public rewardPerTokenStored;\n  uint256 public totalLocked;\n  uint256 public totalVoiceCredits;\n  mapping(address => uint256) public voiceCredits;\n  mapping(address => uint256) public userRewardPerTokenPaid;\n  mapping(address => uint256) public rewards;\n  mapping(address => LockedBalance) public lockedBalances;\n\n  /* ========== EVENTS ========== */\n\n  event StakingDeposited(address _address, uint256 amount);\n  event StakingWithdrawn(address _address, uint256 amount);\n  event RewardPaid(address _address, uint256 reward);\n  event RewardAdded(uint256 reward);\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(IERC20 _token, IRewardsEscrow _rewardsEscrow) {\n    token = _token;\n    rewardsEscrow = _rewardsEscrow;\n\n    _token.safeIncreaseAllowance(address(_rewardsEscrow), type(uint256).max);\n  }\n\n  /* ========== VIEWS ========== */\n\n  /**\n   * @notice this returns the current voice credit balance of an address. voice credits decays over time. the amount returned is up to date, whereas the amount stored in `public voiceCredits` is saved only during some checkpoints.\n   * @dev todo - check if multiplier is needed for calculating square root of smaller balances\n   * @param _address address to get voice credits for\n   */\n  function getVoiceCredits(address _address) public view override returns (uint256) {\n    uint256 lockEndTime = lockedBalances[_address].end;\n    uint256 balance = lockedBalances[_address].balance;\n    uint256 currentTime = block.timestamp;\n\n    if (lockEndTime == 0 || lockEndTime < currentTime || balance == 0) {\n      return 0;\n    }\n\n    uint256 timeTillEnd = ((lockEndTime - currentTime) / 1 hours) * 1 hours;\n    return (balance * timeTillEnd) / (4 * 365 days);\n  }\n\n  function getWithdrawableBalance(address _address) public view override returns (uint256) {\n    uint256 withdrawable = 0;\n    if (lockedBalances[_address].end <= block.timestamp) {\n      withdrawable = lockedBalances[_address].balance;\n    }\n    return withdrawable;\n  }\n\n  function balanceOf(address _address) external view override returns (uint256) {\n    return lockedBalances[_address].balance;\n  }\n\n  function lastTimeRewardApplicable() public view returns (uint256) {\n    return Math.min(block.timestamp, periodFinish);\n  }\n\n  function rewardPerToken() public view returns (uint256) {\n    if (totalLocked == 0) {\n      return rewardPerTokenStored;\n    }\n    return rewardPerTokenStored + (((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18) / totalLocked);\n  }\n\n  function earned(address _account) public view returns (uint256) {\n    return\n      (lockedBalances[_account].balance * (rewardPerToken() - userRewardPerTokenPaid[_account])) /\n      1e18 +\n      rewards[_account];\n  }\n\n  function getRewardForDuration() external view returns (uint256) {\n    return rewardRate * rewardsDuration;\n  }\n\n  function totalSupply() external view returns (uint256) {\n    return totalLocked;\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function stake(uint256 _amount, uint256 _lengthOfTime) external override nonReentrant {\n    _stake(msg.sender, msg.sender, _amount, _lengthOfTime);\n  }\n\n  function stakeFor(\n    address _account,\n    uint256 _amount,\n    uint256 _lengthOfTime\n  ) external override nonReentrant {\n    _stake(_account, msg.sender, _amount, _lengthOfTime);\n  }\n\n  function increaseLock(uint256 _lengthOfTime) external {\n    require(_lengthOfTime >= 7 days, \"must lock tokens for at least 1 week\");\n    require(_lengthOfTime <= 365 * 4 days, \"must lock tokens for less than/equal to  4 year\");\n    require(lockedBalances[msg.sender].balance > 0, \"no lockedBalance exists\");\n    require(lockedBalances[msg.sender].end > block.timestamp, \"withdraw balance first\");\n    lockedBalances[msg.sender].end = lockedBalances[msg.sender].end + _lengthOfTime;\n    recalculateVoiceCredits(msg.sender);\n  }\n\n  function increaseStake(uint256 _amount) external {\n    require(_amount > 0, \"amount must be greater than 0\");\n    require(token.balanceOf(msg.sender) >= _amount, \"insufficient balance\");\n    require(lockedBalances[msg.sender].balance > 0, \"no lockedBalance exists\");\n    require(lockedBalances[msg.sender].end > block.timestamp, \"withdraw balance first\");\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    totalLocked = totalLocked + _amount;\n    lockedBalances[msg.sender].balance = lockedBalances[msg.sender].balance + _amount;\n    recalculateVoiceCredits(msg.sender);\n  }\n\n  function withdraw(uint256 _amount) public override nonReentrant updateReward(msg.sender) {\n    require(_amount > 0, \"amount must be greater than 0\");\n    require(lockedBalances[msg.sender].balance > 0, \"insufficient balance\");\n    require(_amount <= getWithdrawableBalance(msg.sender));\n\n    token.safeTransfer(msg.sender, _amount);\n\n    totalLocked = totalLocked - _amount;\n    _clearWithdrawnFromLocked(_amount);\n    recalculateVoiceCredits(msg.sender);\n    emit StakingWithdrawn(msg.sender, _amount);\n  }\n\n  function getReward() public nonReentrant updateReward(msg.sender) {\n    uint256 reward = rewards[msg.sender];\n    if (reward > 0) {\n      rewards[msg.sender] = 0;\n      uint256 payout = reward / uint256(10);\n      uint256 escrowed = payout * uint256(9);\n\n      token.safeTransfer(msg.sender, payout);\n      rewardsEscrow.lock(msg.sender, escrowed);\n\n      emit RewardPaid(msg.sender, payout);\n    }\n  }\n\n  function exit() external {\n    withdraw(getWithdrawableBalance(msg.sender));\n    getReward();\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  function recalculateVoiceCredits(address _address) public {\n    uint256 previousVoiceCredits = voiceCredits[_address];\n    totalVoiceCredits = totalVoiceCredits - previousVoiceCredits;\n    voiceCredits[_address] = getVoiceCredits(_address);\n    totalVoiceCredits = totalVoiceCredits + voiceCredits[_address];\n  }\n\n  function _stake(\n    address _account,\n    address _tokensFrom,\n    uint256 _amount,\n    uint256 _lengthOfTime\n  ) internal updateReward(_account) {\n    require(_amount > 0, \"amount must be greater than 0\");\n    require(_lengthOfTime >= 12 weeks, \"must lock tokens for at least 12 weeks\");\n    require(_lengthOfTime <= 365 * 4 days, \"must lock tokens for less than/equal to  4 year\");\n    require(token.balanceOf(_tokensFrom) >= _amount, \"insufficient balance\");\n    require(lockedBalances[_account].balance == 0, \"withdraw balance first\");\n\n    token.safeTransferFrom(_tokensFrom, address(this), _amount);\n\n    totalLocked = totalLocked + _amount;\n    _lockTokens(_account, _amount, _lengthOfTime);\n    recalculateVoiceCredits(_account);\n    emit StakingDeposited(_account, _amount);\n  }\n\n  function _lockTokens(\n    address _account,\n    uint256 _amount,\n    uint256 _lengthOfTime\n  ) internal {\n    uint256 currentTime = block.timestamp;\n    if (currentTime > lockedBalances[_account].end) {\n      lockedBalances[_account] = LockedBalance({\n        balance: lockedBalances[_account].balance + _amount,\n        end: currentTime + _lengthOfTime\n      });\n    } else {\n      lockedBalances[_account] = LockedBalance({\n        balance: lockedBalances[_account].balance + _amount,\n        end: lockedBalances[_account].end + _lengthOfTime\n      });\n    }\n  }\n\n  function _clearWithdrawnFromLocked(uint256 _amount) internal {\n    if (lockedBalances[msg.sender].end <= block.timestamp) {\n      if (_amount == lockedBalances[msg.sender].balance) {\n        delete lockedBalances[msg.sender];\n      } else {\n        lockedBalances[msg.sender].balance = lockedBalances[msg.sender].balance - _amount;\n      }\n    }\n  }\n\n  function notifyRewardAmount(uint256 _reward) external override onlyOwner updateReward(address(0)) {\n    if (block.timestamp >= periodFinish) {\n      rewardRate = _reward / rewardsDuration;\n    } else {\n      uint256 remaining = periodFinish - block.timestamp;\n      uint256 leftover = remaining * rewardRate;\n      rewardRate = (_reward + leftover) / rewardsDuration;\n    }\n\n    // Ensure the provided reward amount is not more than the balance in the contract.\n    // This keeps the reward rate in the right range, preventing overflows due to\n    // very high values of rewardRate in the earned and rewardsPerToken functions;\n    // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n    uint256 balance = token.balanceOf(address(this));\n    require(rewardRate <= (balance / rewardsDuration), \"Provided reward too high\");\n\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp + rewardsDuration;\n    emit RewardAdded(_reward);\n  }\n\n  // End rewards emission earlier\n  function updatePeriodFinish(uint256 _timestamp) external onlyOwner updateReward(address(0)) {\n    require(_timestamp > block.timestamp, \"timestamp cant be in the past\");\n    periodFinish = _timestamp;\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier updateReward(address _account) {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (_account != address(0)) {\n      rewards[_account] = earned(_account);\n      userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n    }\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/core/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IStaking {\n  function balanceOf(address account) external view returns (uint256);\n\n  function stake(uint256 amount, uint256 lengthOfTime) external;\n\n  function stakeFor(\n    address account,\n    uint256 amount,\n    uint256 lengthOfTime\n  ) external;\n\n  function withdraw(uint256 amount) external;\n\n  function getVoiceCredits(address _address) external view returns (uint256);\n\n  function getWithdrawableBalance(address _address) external view returns (uint256);\n\n  function notifyRewardAmount(uint256 reward) external;\n}\n"
    },
    "contracts/core/interfaces/IRewardsManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IRewardsManager {}\n"
    },
    "contracts/core/interfaces/IRewardsEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IRewardsEscrow {\n  function lock(address _address, uint256 _amount) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/core/dao/Staking.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IStakingRewards.sol\";\nimport \"../interfaces/IRewardsEscrow.sol\";\n\n// https://docs.synthetix.io/contracts/source/contracts/stakingrewards\ncontract Staking is IStakingRewards, Ownable, ReentrancyGuard, Pausable {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ========== STATE VARIABLES ========== */\n\n  IERC20 public rewardsToken;\n  IERC20 public stakingToken;\n  IRewardsEscrow public rewardsEscrow;\n  uint256 public periodFinish = 0;\n  uint256 public rewardRate = 0;\n  uint256 public rewardsDuration = 7 days;\n  uint256 public lastUpdateTime;\n  uint256 public rewardPerTokenStored;\n\n  mapping(address => uint256) public userRewardPerTokenPaid;\n  mapping(address => uint256) public rewards;\n\n  uint256 private _totalSupply;\n  mapping(address => uint256) private _balances;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    IERC20 _rewardsToken,\n    IERC20 _stakingToken,\n    IRewardsEscrow _rewardsEscrow\n  ) {\n    rewardsToken = _rewardsToken;\n    stakingToken = _stakingToken;\n    rewardsEscrow = _rewardsEscrow;\n\n    _rewardsToken.safeIncreaseAllowance(address(_rewardsEscrow), type(uint256).max);\n  }\n\n  /* ========== VIEWS ========== */\n\n  function totalSupply() external view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) external view override returns (uint256) {\n    return _balances[account];\n  }\n\n  function lastTimeRewardApplicable() public view override returns (uint256) {\n    return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n  }\n\n  function rewardPerToken() public view override returns (uint256) {\n    if (_totalSupply == 0) {\n      return rewardPerTokenStored;\n    }\n    return\n      rewardPerTokenStored.add(\n        lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)\n      );\n  }\n\n  function earned(address account) public view override returns (uint256) {\n    return\n      _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n  }\n\n  function getRewardForDuration() external view override returns (uint256) {\n    return rewardRate.mul(rewardsDuration);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function stake(uint256 amount) external override nonReentrant whenNotPaused updateReward(msg.sender) {\n    require(amount > 0, \"Cannot stake 0\");\n    _totalSupply = _totalSupply.add(amount);\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\n    stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n    emit Staked(msg.sender, amount);\n  }\n\n  function withdraw(uint256 amount) public override nonReentrant updateReward(msg.sender) {\n    require(amount > 0, \"Cannot withdraw 0\");\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\n    stakingToken.safeTransfer(msg.sender, amount);\n    emit Withdrawn(msg.sender, amount);\n  }\n\n  function getReward() public override nonReentrant updateReward(msg.sender) {\n    uint256 reward = rewards[msg.sender];\n    if (reward > 0) {\n      rewards[msg.sender] = 0;\n      uint256 payout = reward / uint256(10);\n      uint256 escrowed = payout * uint256(9);\n\n      rewardsToken.safeTransfer(msg.sender, payout);\n      rewardsEscrow.lock(msg.sender, escrowed);\n      emit RewardPaid(msg.sender, reward);\n    }\n  }\n\n  function exit() external override {\n    withdraw(_balances[msg.sender]);\n    getReward();\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  function notifyRewardAmount(uint256 reward) external override onlyOwner updateReward(address(0)) {\n    if (block.timestamp >= periodFinish) {\n      rewardRate = reward.div(rewardsDuration);\n    } else {\n      uint256 remaining = periodFinish.sub(block.timestamp);\n      uint256 leftover = remaining.mul(rewardRate);\n      rewardRate = reward.add(leftover).div(rewardsDuration);\n    }\n\n    // Ensure the provided reward amount is not more than the balance in the contract.\n    // This keeps the reward rate in the right range, preventing overflows due to\n    // very high values of rewardRate in the earned and rewardsPerToken functions;\n    // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n    uint256 balance = rewardsToken.balanceOf(address(this));\n    require(rewardRate <= balance.div(rewardsDuration), \"Provided reward too high\");\n\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp.add(rewardsDuration);\n    emit RewardAdded(reward);\n  }\n\n  // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n  function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n    require(tokenAddress != address(stakingToken), \"Cannot withdraw the staking token\");\n    IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n    require(\n      block.timestamp > periodFinish,\n      \"Previous rewards period must be complete before changing the duration for the new period\"\n    );\n    rewardsDuration = _rewardsDuration;\n    emit RewardsDurationUpdated(rewardsDuration);\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier updateReward(address account) {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account != address(0)) {\n      rewards[account] = earned(account);\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n    _;\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RewardAdded(uint256 reward);\n  event Staked(address indexed user, uint256 amount);\n  event Withdrawn(address indexed user, uint256 amount);\n  event RewardPaid(address indexed user, uint256 reward);\n  event RewardsDurationUpdated(uint256 newDuration);\n  event Recovered(address token, uint256 amount);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/core/interfaces/IStakingRewards.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// https://docs.synthetix.io/contracts/source/interfaces/istakingrewards\ninterface IStakingRewards {\n  // Views\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function lastTimeRewardApplicable() external view returns (uint256);\n\n  function rewardPerToken() external view returns (uint256);\n\n  function earned(address account) external view returns (uint256);\n\n  function getRewardForDuration() external view returns (uint256);\n\n  // Mutative\n  function stake(uint256 amount) external;\n\n  function withdraw(uint256 amount) external;\n\n  function getReward() external;\n\n  function exit() external;\n\n  function notifyRewardAmount(uint256 reward) external;\n}\n"
    },
    "contracts/test_helpers/Faucet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface Uniswap {\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function WETH() external pure returns (address);\n}\n\ninterface CurveDepositZap {\n  function add_liquidity(\n    address pool,\n    uint256[4] calldata amounts,\n    uint256 min_mint_amounts,\n    address receiver\n  ) external returns (uint256);\n}\n\ninterface TriPool {\n  function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amounts) external;\n}\n\ninterface CurveAddressProvider {\n  function get_registry() external view returns (address);\n}\n\ninterface CurveRegistry {\n  function get_pool_from_lp_token(address lp_token) external view returns (address);\n}\n\ncontract Faucet {\n  Uniswap public uniswap;\n  CurveDepositZap public curveDepositZap;\n  CurveAddressProvider public curveAddressProvider;\n  CurveRegistry public curveRegistry;\n  address public triPool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\n  IERC20 public dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n  IERC20 public threeCrv = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n\n  constructor(\n    address uniswap_,\n    address curveAddressProvider_,\n    address curveDepositZap_\n  ) {\n    uniswap = Uniswap(uniswap_);\n    curveDepositZap = CurveDepositZap(curveDepositZap_);\n    curveAddressProvider = CurveAddressProvider(curveAddressProvider_);\n    curveRegistry = CurveRegistry(curveAddressProvider.get_registry());\n    dai.approve(address(curveDepositZap), type(uint256).max);\n    dai.approve(address(triPool), type(uint256).max);\n  }\n\n  function sendTokens(\n    address token,\n    uint256 amount,\n    address recipient\n  ) public {\n    address[] memory path = new address[](2);\n    path[0] = uniswap.WETH();\n    path[1] = token;\n    uniswap.swapExactETHForTokens{value: amount * 1 ether}(0, path, recipient, block.timestamp);\n  }\n\n  function sendCurveLPTokens(\n    address lpToken,\n    uint256 amount,\n    address recipient\n  ) public {\n    address[] memory path = new address[](2);\n    path[0] = uniswap.WETH();\n    path[1] = address(dai);\n    uint256 daiAmount = uniswap.swapExactETHForTokens{value: amount * 1 ether}(0, path, address(this), block.timestamp)[\n      1\n    ];\n    address curvePool = curveRegistry.get_pool_from_lp_token(lpToken);\n    curveDepositZap.add_liquidity(curvePool, [0, daiAmount, 0, 0], 0, recipient);\n  }\n\n  function sendThreeCrv(uint256 amount, address recipient) public {\n    address[] memory path = new address[](2);\n    path[0] = uniswap.WETH();\n    path[1] = address(dai);\n    uint256 daiAmount = uniswap.swapExactETHForTokens{value: amount * 1 ether}(0, path, address(this), block.timestamp)[\n      1\n    ];\n    TriPool(triPool).add_liquidity([daiAmount, 0, 0], 0);\n    threeCrv.transfer(recipient, threeCrv.balanceOf(address(this)));\n  }\n}\n"
    },
    "contracts/mocks/MockCurveMetapool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Docgen-SOLC: 0.8.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./MockERC20.sol\";\n\ncontract MockCurveMetapool {\n  using SafeERC20 for MockERC20;\n\n  MockERC20 public lpToken;\n  MockERC20 public threeCrv;\n  MockERC20 token;\n  MockERC20 dai;\n  MockERC20 usdc;\n  MockERC20 usdt;\n  uint256 virtualPrice = 1e18;\n\n  uint256 withdrawalSlippageBps = 10;\n\n  uint256 BPS_DENOMINATOR = 10000;\n  MockERC20[] tokens;\n\n  constructor(\n    address token_,\n    address lpToken_,\n    address threeCrv_,\n    address dai_,\n    address usdc_,\n    address usdt_\n  ) {\n    token = MockERC20(token_);\n    lpToken = MockERC20(lpToken_);\n    threeCrv = MockERC20(threeCrv_);\n    dai = MockERC20(dai_);\n    usdc = MockERC20(usdc_);\n    usdt = MockERC20(usdt_);\n    tokens = [token, threeCrv];\n  }\n\n  function coins() external view returns (address[2] memory) {\n    address[2] memory coinAddresses = [address(token), address(threeCrv)];\n    return coinAddresses;\n  }\n\n  function base_coins() external view returns (address[3] memory) {\n    address[3] memory coinAddresses = [\n      address(dai),\n      address(usdc),\n      address(usdt)\n    ];\n    return coinAddresses;\n  }\n\n  function get_virtual_price() external view returns (uint256) {\n    return virtualPrice;\n  }\n\n  function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n    external\n    view\n    returns (uint256)\n  {\n    return _token_amount;\n  }\n\n  function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amounts)\n    external\n    returns (uint256)\n  {\n    uint256 lpTokens;\n    for (uint8 i = 0; i < tokens.length; i++) {\n      tokens[i].transferFrom(msg.sender, address(this), amounts[i]);\n      lpToken.mint(msg.sender, amounts[i]);\n      lpTokens += amounts[i];\n    }\n    return lpTokens;\n  }\n\n  function remove_liquidity_one_coin(\n    uint256 _token_amount,\n    int128 i,\n    uint256 _min_amount\n  ) external returns (uint256) {\n    lpToken.transferFrom(msg.sender, address(this), _token_amount);\n\n    uint256 slippage = (_token_amount * withdrawalSlippageBps) / 10000;\n    uint256 transferOut = _token_amount - slippage;\n    uint128 idx = uint128(i);\n    tokens[idx].approve(address(this), transferOut);\n    tokens[idx].mint(address(this), transferOut);\n    tokens[idx].transferFrom(address(this), msg.sender, transferOut);\n    return transferOut;\n  }\n\n  // Test helpers\n\n  function setVirtualPrice(uint256 virtualPrice_) external {\n    virtualPrice = virtualPrice_;\n  }\n\n  function setWithdrawalSlippage(uint256 withdrawalSlippageBps_) external {\n    withdrawalSlippageBps = withdrawalSlippageBps_;\n  }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n  uint8 public __decimals = 18;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals\n  ) ERC20(_name, _symbol) {\n    __decimals = _decimals;\n  }\n\n  function decimals() public view virtual override returns (uint8) {\n    return __decimals;\n  }\n\n  function mint(address to_, uint256 amount_) public {\n    _mint(to_, amount_);\n  }\n\n  function burn(address from_, uint256 amount_) public {\n    _burn(from_, amount_);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/mocks/MockYearnV2Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Docgen-SOLC: 0.8.0\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./MockERC20.sol\";\n\ncontract MockYearnV2Vault is MockERC20 {\n  using SafeERC20 for MockERC20;\n  using SafeMath for uint256;\n\n  MockERC20 public token;\n\n  constructor(address token_) MockERC20(\"Mock crvUSDX yVault\", \"yvUSDX\", 18) {\n    token = MockERC20(token_);\n  }\n\n  function maxAvailableShares() external view returns (uint256) {\n    return totalSupply();\n  }\n\n  function balance() public view returns (uint256) {\n    return token.balanceOf(address(this));\n  }\n\n  function totalAssets() external view returns (uint256) {\n    return token.balanceOf(address(this));\n  }\n\n  function pricePerShare() public view returns (uint256) {\n    if (totalSupply() == 0) {\n      return 1e18;\n    }\n    return balance().mul(1e18).div(totalSupply());\n  }\n\n  function deposit(uint256 amount) external returns (uint256) {\n    token.transferFrom(msg.sender, address(this), amount);\n    return _issueSharesForAmount(msg.sender, amount);\n  }\n\n  function deposit(uint256 amount, address recipient)\n    external\n    returns (uint256)\n  {\n    token.transferFrom(msg.sender, address(this), amount);\n    return _issueSharesForAmount(recipient, amount);\n  }\n\n  function withdraw(uint256 amount) external returns (uint256) {\n    uint256 tokenAmount = _shareValue(amount);\n    _burn(msg.sender, amount);\n    token.approve(address(this), tokenAmount);\n    token.transferFrom(address(this), msg.sender, tokenAmount);\n    return tokenAmount;\n  }\n\n  function _issueSharesForAmount(address to, uint256 amount)\n    internal\n    returns (uint256)\n  {\n    uint256 shares = 0;\n    if (this.totalSupply() == 0) {\n      shares = amount;\n    } else {\n      shares = (amount * this.totalSupply()) / this.totalAssets();\n    }\n    _mint(to, shares);\n    return shares;\n  }\n\n  function _shareValue(uint256 shares) internal view returns (uint256) {\n    if (this.totalSupply() == 0) {\n      return shares;\n    }\n    return (shares * this.totalAssets()) / this.totalSupply();\n  }\n\n  // Test helpers\n\n  function increasePricePerFullShare(uint256 multiplier) external {\n    uint256 newPrice = pricePerShare().mul(multiplier).div(1e18);\n    token.burn(address(this), token.balanceOf(address(this)));\n    uint256 balanceAmount = newPrice.mul(totalSupply()).div(1e18);\n    token.mint(address(this), balanceAmount);\n  }\n\n  function setPricePerFullShare(uint256 pricePerFullShare) external {\n    token.burn(address(this), token.balanceOf(address(this)));\n    uint256 balanceAmount = pricePerFullShare.mul(totalSupply()).div(1e18);\n    token.mint(address(this), balanceAmount);\n  }\n}\n"
    },
    "contracts/mocks/MockBasicIssuanceModule.sol": {
      "content": "// Docgen-SOLC: 0.8.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./MockERC20.sol\";\n\ncontract MockBasicIssuanceModule {\n  using SafeERC20 for MockERC20;\n\n  address[] public underlying;\n  uint256[] public quantities;\n\n  event SetIssued(address setToken, uint256 amount, address to);\n  event SetRedeemed(address setToken, uint256 amount, address to);\n\n  constructor(address[] memory underlying_, uint256[] memory quantities_) {\n    underlying = underlying_;\n    quantities = quantities_;\n  }\n\n  function issue(\n    address _setToken,\n    uint256 _quantity,\n    address _to\n  ) external {\n    for (uint256 i; i < underlying.length; i++) {\n      uint256 amount = _quantity * quantities[i];\n      require(\n        MockERC20(underlying[i]).balanceOf(msg.sender) >= amount,\n        \"not enough underlying token\"\n      );\n      MockERC20(underlying[i]).transferFrom(msg.sender, address(this), amount);\n    }\n    MockERC20(_setToken).mint(_to, _quantity);\n    emit SetIssued(_setToken, _quantity, _to);\n  }\n\n  function redeem(\n    address _setToken,\n    uint256 _quantity,\n    address _to\n  ) external {\n    require(MockERC20(_setToken).balanceOf(msg.sender) >= _quantity);\n    MockERC20(_setToken).transferFrom(msg.sender, address(this), _quantity);\n    for (uint256 i; i < underlying.length; i++) {\n      uint256 amount = _quantity * quantities[i];\n      MockERC20(underlying[i]).approve(address(this), amount);\n      MockERC20(underlying[i]).transfer(_to, amount);\n    }\n    emit SetRedeemed(_setToken, _quantity, msg.sender);\n  }\n\n  function getRequiredComponentUnitsForIssue(\n    address _setToken,\n    uint256 _quantity\n  ) public view returns (address[] memory, uint256[] memory) {\n    uint256[] memory notionalUnits = new uint256[](underlying.length);\n\n    for (uint256 i = 0; i < underlying.length; i++) {\n      notionalUnits[i] = _quantity * quantities[i];\n    }\n\n    return (underlying, notionalUnits);\n  }\n}\n"
    },
    "contracts/core/defi/butter/ButterBatchProcessingZapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BatchType, Batch, IButterBatchProcessing} from \"../../interfaces/IButterBatchProcessing.sol\";\nimport \"../../../externals/interfaces/Curve3Pool.sol\";\nimport \"../../interfaces/IContractRegistry.sol\";\n\n/*\nThis Contract allows user to use and receive stablecoins directly when interacting with HysiBatchInteraction.\nThis contract mainly takes stablecoins swaps them into 3CRV and deposits them or the other way around.\n */\ncontract ButterBatchProcessingZapper {\n  using SafeERC20 for IERC20;\n\n  /* ========== STATE VARIABLES ========== */\n\n  IContractRegistry private contractRegistry;\n  Curve3Pool private curve3Pool;\n  IERC20 private threeCrv;\n\n  /* ========== EVENTS ========== */\n\n  event ZappedIntoBatch(uint256 threeCurveAmount, address account);\n  event ZappedOutOfBatch(\n    bytes32 batchId,\n    uint8 stableCoinIndex,\n    uint256 threeCurveAmount,\n    uint256 stableCoinAmount,\n    address account\n  );\n  event ClaimedIntoStable(\n    bytes32 batchId,\n    uint8 stableCoinIndex,\n    uint256 threeCurveAmount,\n    uint256 stableCoinAmount,\n    address account\n  );\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    IContractRegistry _contractRegistry,\n    Curve3Pool _curve3Pool,\n    IERC20 _threeCrv\n  ) {\n    contractRegistry = _contractRegistry;\n    curve3Pool = _curve3Pool;\n    threeCrv = _threeCrv;\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @notice zapIntoBatch allows a user to deposit into a mintBatch directly with stablecoins\n   * @param _amounts An array of amounts in stablecoins the user wants to deposit\n   * @param _min_mint_amounts The min amount of 3CRV which should be minted by the curve three-pool (slippage control)\n   * @dev The amounts in _amounts must align with their index in the curve three-pool\n   */\n  function zapIntoBatch(uint256[3] memory _amounts, uint256 _min_mint_amounts) external {\n    address butterBatchProcessing = contractRegistry.getContract(keccak256(\"ButterBatchProcessing\"));\n    for (uint8 i; i < _amounts.length; i++) {\n      if (_amounts[i] > 0) {\n        //Deposit Stables\n        IERC20(curve3Pool.coins(i)).safeTransferFrom(msg.sender, address(this), _amounts[i]);\n        //Allow Stables for user in curve three-pool\n        IERC20(curve3Pool.coins(i)).safeIncreaseAllowance(address(curve3Pool), _amounts[i]);\n      }\n    }\n    //Deposit stables to receive 3CRV\n    curve3Pool.add_liquidity(_amounts, _min_mint_amounts);\n\n    //Check the amount of returned 3CRV\n    /*\n    While curves metapools return the amount of minted 3CRV this is not possible with the three-pool which is why we simply have to check our balance after depositing our stables.\n    If a user sends 3CRV to this contract by accident (Which cant be retrieved anyway) they will be used aswell.\n    */\n    uint256 threeCrvAmount = threeCrv.balanceOf(address(this));\n\n    //Allow hysiBatchInteraction to use 3CRV\n    threeCrv.safeIncreaseAllowance(butterBatchProcessing, threeCrvAmount);\n\n    //Deposit 3CRV in current mint batch\n    IButterBatchProcessing(butterBatchProcessing).depositForMint(threeCrvAmount, msg.sender);\n    emit ZappedIntoBatch(threeCrvAmount, msg.sender);\n  }\n\n  /**\n   * @notice zapOutOfBatch allows a user to retrieve their not yet processed 3CRV and directly receive stablecoins\n   * @param _batchId Defines which batch gets withdrawn from\n   * @param _amountToWithdraw 3CRV amount that shall be withdrawn\n   * @param _stableCoinIndex Defines which stablecoin the user wants to receive\n   * @param _min_amount The min amount of stables which should be returned by the curve three-pool (slippage control)\n   * @dev The _stableCoinIndex must align with the index in the curve three-pool\n   */\n  function zapOutOfBatch(\n    bytes32 _batchId,\n    uint256 _amountToWithdraw,\n    uint8 _stableCoinIndex,\n    uint256 _min_amount\n  ) external {\n    // Allows the zapepr to withdraw 3CRV from batch for the user\n    IButterBatchProcessing(contractRegistry.getContract(keccak256(\"ButterBatchProcessing\"))).withdrawFromBatch(\n      _batchId,\n      _amountToWithdraw,\n      msg.sender\n    );\n\n    //Burns 3CRV for stables and sends them to the user\n    //stableBalance is only returned for the event\n    uint256 stableBalance = _swapAndTransfer3Crv(_amountToWithdraw, _stableCoinIndex, _min_amount);\n\n    emit ZappedOutOfBatch(_batchId, _stableCoinIndex, _amountToWithdraw, stableBalance, msg.sender);\n  }\n\n  /**\n   * @notice claimAndSwapToStable allows a user to claim their processed 3CRV from a redeemBatch and directly receive stablecoins\n   * @param _batchId Defines which batch gets withdrawn from\n   * @param _stableCoinIndex Defines which stablecoin the user wants to receive\n   * @param _min_amount The min amount of stables which should be returned by the curve three-pool (slippage control)\n   * @dev The _stableCoinIndex must align with the index in the curve three-pool\n   */\n  function claimAndSwapToStable(\n    bytes32 _batchId,\n    uint8 _stableCoinIndex,\n    uint256 _min_amount\n  ) external {\n    //We can only deposit 3CRV which come from mintBatches otherwise this could claim HYSI which we cant process here\n    IButterBatchProcessing butterBatchProcessing = IButterBatchProcessing(\n      contractRegistry.getContract(keccak256(\"ButterBatchProcessing\"))\n    );\n    require(butterBatchProcessing.batches(_batchId).batchType == BatchType.Redeem, \"needs to return 3crv\");\n\n    //Zapper claims 3CRV for the user\n    uint256 threeCurveAmount = butterBatchProcessing.claim(_batchId, msg.sender);\n\n    //Burns 3CRV for stables and sends them to the user\n    //stableBalance is only returned for the event\n    uint256 stableBalance = _swapAndTransfer3Crv(threeCurveAmount, _stableCoinIndex, _min_amount);\n\n    emit ClaimedIntoStable(_batchId, _stableCoinIndex, threeCurveAmount, stableBalance, msg.sender);\n  }\n\n  /**\n   * @notice _swapAndTransfer3Crv burns 3CRV and sends the returned stables to the user\n   * @param _threeCurveAmount How many 3CRV shall be burned\n   * @param _stableCoinIndex Defines which stablecoin the user wants to receive\n   * @param _min_amount The min amount of stables which should be returned by the curve three-pool (slippage control)\n   * @dev The stableCoinIndex_ must align with the index in the curve three-pool\n   */\n  function _swapAndTransfer3Crv(\n    uint256 _threeCurveAmount,\n    uint8 _stableCoinIndex,\n    uint256 _min_amount\n  ) internal returns (uint256) {\n    //Allow curve three-pool to use 3CRV\n    threeCrv.safeIncreaseAllowance(address(curve3Pool), _threeCurveAmount);\n\n    //Burn 3CRV to receive stables\n    curve3Pool.remove_liquidity_one_coin(_threeCurveAmount, _stableCoinIndex, _min_amount);\n\n    //Check the amount of returned stables\n    /*\n    If a user sends Stables to this contract by accident (Which cant be retrieved anyway) they will be used aswell.\n    */\n    uint256 stableBalance = IERC20(curve3Pool.coins(_stableCoinIndex)).balanceOf(address(this));\n\n    //Transfer stables to user\n    IERC20(curve3Pool.coins(_stableCoinIndex)).safeTransfer(msg.sender, stableBalance);\n\n    //Return stablebalance for event\n    return stableBalance;\n  }\n}\n"
    },
    "contracts/core/interfaces/IButterBatchProcessing.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nenum BatchType {\n  Mint,\n  Redeem\n}\n\nstruct Batch {\n  BatchType batchType;\n  bytes32 batchId;\n  bool claimable;\n  uint256 unclaimedShares;\n  uint256 suppliedTokenBalance;\n  uint256 claimableTokenBalance;\n  address suppliedTokenAddress;\n  address claimableTokenAddress;\n}\n\ninterface IButterBatchProcessing {\n  function batches(bytes32 batchId) external view returns (Batch memory);\n\n  function depositForMint(uint256 amount_, address account_) external;\n\n  function claim(bytes32 batchId_, address account_) external returns (uint256);\n\n  function withdrawFromBatch(\n    bytes32 batchId_,\n    uint256 amountToWithdraw_,\n    address account_\n  ) external;\n}\n"
    },
    "contracts/externals/interfaces/Curve3Pool.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface Curve3Pool {\n  function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amounts)\n    external;\n\n  function remove_liquidity_one_coin(\n    uint256 burn_amount,\n    int128 i,\n    uint256 min_amount\n  ) external;\n\n  function get_virtual_price() external view returns (uint256);\n\n  function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n    external\n    view\n    returns (uint256);\n\n  function coins(uint256 i) external view returns (address);\n\n  function calc_token_amount(uint256[3] calldata amounts, bool deposit)\n    external\n    view\n    returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IContractRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of ContractRegistry.\n */\ninterface IContractRegistry {\n  function getContract(bytes32 _name) external view returns (address);\n}\n"
    },
    "contracts/core/utils/ContractRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IACLRegistry.sol\";\nimport \"../interfaces/IContractRegistry.sol\";\n\n/**\n * @dev This Contract holds reference to all our contracts. Every contract A that needs to interact with another contract B calls this contract\n * to ask for the address of B.\n * This allows us to update addresses in one central point and reduces constructing and management overhead.\n */\ncontract ContractRegistry is IContractRegistry {\n  struct Contract {\n    address contractAddress;\n    bytes32 version;\n  }\n\n  /* ========== STATE VARIABLES ========== */\n\n  IACLRegistry public aclRegistry;\n\n  mapping(bytes32 => Contract) public contracts;\n  bytes32[] public contractNames;\n\n  /* ========== EVENTS ========== */\n\n  event ContractAdded(bytes32 _name, address _address, bytes32 _version);\n  event ContractUpdated(bytes32 _name, address _address, bytes32 _version);\n  event ContractDeleted(bytes32 _name);\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(IACLRegistry _aclRegistry) {\n    aclRegistry = _aclRegistry;\n    contracts[keccak256(\"ACLRegistry\")] = Contract({contractAddress: address(_aclRegistry), version: keccak256(\"1\")});\n    contractNames.push(keccak256(\"ACLRegistry\"));\n  }\n\n  /* ========== VIEW FUNCTIONS ========== */\n\n  function getContractNames() external view returns (bytes32[] memory) {\n    return contractNames;\n  }\n\n  function getContract(bytes32 _name) external view override returns (address) {\n    return contracts[_name].contractAddress;\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function addContract(\n    bytes32 _name,\n    address _address,\n    bytes32 _version\n  ) external {\n    aclRegistry.requireRole(keccak256(\"DAO\"), msg.sender);\n    require(contracts[_name].contractAddress == address(0), \"contract already exists\");\n    contracts[_name] = Contract({contractAddress: _address, version: _version});\n    contractNames.push(_name);\n    emit ContractAdded(_name, _address, _version);\n  }\n\n  function updateContract(\n    bytes32 _name,\n    address _newAddress,\n    bytes32 _version\n  ) external {\n    aclRegistry.requireRole(keccak256(\"DAO\"), msg.sender);\n    require(contracts[_name].contractAddress != address(0), \"contract doesnt exist\");\n    contracts[_name] = Contract({contractAddress: _newAddress, version: _version});\n    emit ContractUpdated(_name, _newAddress, _version);\n  }\n\n  function deleteContract(bytes32 _name, uint256 _contractIndex) external {\n    aclRegistry.requireRole(keccak256(\"DAO\"), msg.sender);\n    require(contracts[_name].contractAddress != address(0), \"contract doesnt exist\");\n    require(contractNames[_contractIndex] == _name, \"this is not the contract you are looking for\");\n    delete contracts[_name];\n    delete contractNames[_contractIndex];\n    emit ContractDeleted(_name);\n  }\n}\n"
    },
    "contracts/core/interfaces/IACLRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IACLRegistry {\n  /**\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n   *\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n   * {RoleAdminChanged} not being emitted signaling this.\n   *\n   * _Available since v3.1._\n   */\n  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n  /**\n   * @dev Emitted when `account` is granted `role`.\n   *\n   * `sender` is the account that originated the contract call, an admin role\n   * bearer except when using {AccessControl-_setupRole}.\n   */\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n  /**\n   * @dev Emitted when `account` is revoked `role`.\n   *\n   * `sender` is the account that originated the contract call:\n   *   - if using `revokeRole`, it is the admin role bearer\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n   */\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  /**\n   * @dev Returns `true` if `account` has been granted `permission`.\n   */\n  function hasPermission(bytes32 permission, address account) external view returns (bool);\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) external;\n\n  function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n\n  function grantPermission(bytes32 permission, address account) external;\n\n  function revokePermission(bytes32 permission) external;\n\n  function requireApprovedContractOrEOA(address account) external view;\n\n  function requireRole(bytes32 role, address account) external view;\n\n  function requirePermission(bytes32 permission, address account) external view;\n\n  function isRoleAdmin(bytes32 role, address account) external view;\n}\n"
    },
    "contracts/test_helpers/ACLRegistryHelper.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"../core/interfaces/IACLRegistry.sol\";\n\ncontract ACLRegistryHelper {\n  IACLRegistry public aclRegistry;\n\n  constructor(IACLRegistry _aclRegistry) {\n    aclRegistry = _aclRegistry;\n  }\n\n  function senderProtected(bytes32 role) public view {\n    require(aclRegistry.hasRole(role, msg.sender), \"you dont have the required role\");\n  }\n}\n"
    },
    "contracts/core/utils/ACLRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IACLRegistry.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\ncontract ACLRegistry is IACLRegistry {\n  /* ========== STATE VARIABLES ========== */\n\n  struct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n  }\n\n  mapping(bytes32 => RoleData) private _roles;\n  mapping(bytes32 => address) private _permissions;\n\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor() {\n    _roles[DEFAULT_ADMIN_ROLE].members[msg.sender] = true;\n  }\n\n  /* ========== VIEW FUNCTIONS ========== */\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) public view override returns (bool) {\n    return _roles[role].members[account];\n  }\n\n  /**\n   * @dev Returns `true` if `account` has been granted `permission`.\n   */\n  function hasPermission(bytes32 permission, address account) public view override returns (bool) {\n    return _permissions[permission] == account;\n  }\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n    return _roles[role].adminRole;\n  }\n\n  function requireRole(bytes32 role, address account) public view override {\n    require(hasRole(role, account), \"you dont have the right role\");\n  }\n\n  function requirePermission(bytes32 permission, address account) public view override {\n    require(hasPermission(permission, account), \"you dont have the right permissions\");\n  }\n\n  function isRoleAdmin(bytes32 role, address account) public view override {\n    require(hasRole(getRoleAdmin(role), account), \"you have to be role admin\");\n  }\n\n  function requireApprovedContractOrEOA(address account) public view override {\n    require(hasRole(keccak256(\"ApprovedContract\"), account) || account == tx.origin, \"Access denied for caller\");\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account) public override onlyRole(getRoleAdmin(role)) {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account) public override onlyRole(getRoleAdmin(role)) {\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) public override {\n    require(account == msg.sender || hasRole(getRoleAdmin(role), msg.sender), \"you cant renounce this role\");\n\n    _revokeRole(role, account);\n  }\n\n  function setRoleAdmin(bytes32 role, bytes32 adminRole) public override {\n    require(\n      hasRole(getRoleAdmin(role), msg.sender) || hasRole(DEFAULT_ADMIN_ROLE, msg.sender),\n      \"can only renounce roles for self\"\n    );\n\n    _setRoleAdmin(role, adminRole);\n  }\n\n  function grantPermission(bytes32 permission, address account) public override {\n    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"only for admin\");\n    _permissions[permission] = account;\n  }\n\n  function revokePermission(bytes32 permission) public override {\n    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"only for admin\");\n    delete _permissions[permission];\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /**\n   * @dev Revert with a standard message if `account` is missing `role`.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   */\n  function _requireRole(bytes32 role, address account) internal view {\n    require(hasRole(role, account), \"you dont have the required role\");\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event. Note that unlike {grantRole}, this function doesn't perform any\n   * checks on the calling account.\n   *\n   * [WARNING]\n   * ====\n   * This function should only be called from the constructor when setting\n   * up the initial roles for the system.\n   *\n   * Using this function in any other way is effectively circumventing the admin\n   * system imposed by {AccessControl}.\n   * ====\n   */\n  function _setupRole(bytes32 role, address account) internal {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Sets `adminRole` as ``role``'s admin role.\n   *\n   * Emits a {RoleAdminChanged} event.\n   */\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n    bytes32 previousAdminRole = getRoleAdmin(role);\n    _roles[role].adminRole = adminRole;\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\n  }\n\n  function _grantRole(bytes32 role, address account) private {\n    if (!hasRole(role, account)) {\n      _roles[role].members[account] = true;\n      emit RoleGranted(role, account, msg.sender);\n    }\n  }\n\n  function _revokeRole(bytes32 role, address account) private {\n    if (hasRole(role, account)) {\n      _roles[role].members[account] = false;\n      emit RoleRevoked(role, account, msg.sender);\n    }\n  }\n\n  /* ========== MODIFIER ========== */\n\n  /**\n   * @dev Modifier that checks that an account has a specific role. Reverts\n   * with a standardized message including the required role.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   *\n   * _Available since v4.1._\n   */\n  modifier onlyRole(bytes32 role) {\n    _requireRole(role, msg.sender);\n    _;\n  }\n}\n"
    },
    "contracts/core/utils/KeeperIncentive.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IACLRegistry.sol\";\nimport \"../interfaces/IContractRegistry.sol\";\nimport \"../interfaces/IStaking.sol\";\n\ncontract KeeperIncentive {\n  using SafeERC20 for IERC20;\n\n  struct Incentive {\n    uint256 reward; //pop reward for calling the function\n    bool enabled;\n    bool openToEveryone; //can everyone call the function to get the reward or only approved?\n  }\n\n  /* ========== STATE VARIABLES ========== */\n\n  IContractRegistry public contractRegistry;\n\n  uint256 public incentiveBudget;\n  mapping(bytes32 => Incentive[]) public incentives;\n  mapping(bytes32 => address) public controllerContracts;\n  uint256 public burnRate;\n  address internal immutable burnAddress =\n    0x00000000219ab540356cBB839Cbe05303d7705Fa; //ETH2.0 Staking Contract\n  uint256 public requiredKeeperStake;\n\n  /* ========== EVENTS ========== */\n\n  event IncentiveCreated(\n    bytes32 contractName,\n    uint256 reward,\n    bool openToEveryone\n  );\n  event IncentiveChanged(\n    bytes32 contractName,\n    uint256 oldReward,\n    uint256 newReward,\n    bool oldOpenToEveryone,\n    bool newOpenToEveryone\n  );\n  event IncentiveFunded(uint256 amount);\n  event ApprovalToggled(bytes32 contractName, bool openToEveryone);\n  event IncentiveToggled(bytes32 contractName, bool enabled);\n  event ControllerContractAdded(bytes32 contractName, address contractAddress);\n  event Burned(uint256 amount);\n  event BurnRateChanged(uint256 oldRate, uint256 newRate);\n  event RequiredKeeperStakeChanged(\n    uint256 oldRequirement,\n    uint256 newRequirement\n  );\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    IContractRegistry _contractRegistry,\n    uint256 _burnRate,\n    uint256 _requiredKeeperStake\n  ) public {\n    contractRegistry = _contractRegistry;\n    burnRate = _burnRate; //25e16\n    requiredKeeperStake = _requiredKeeperStake; // 2000 ether\n  }\n\n  /* ==========  MUTATIVE FUNCTIONS  ========== */\n\n  function handleKeeperIncentive(\n    bytes32 _contractName,\n    uint8 _i,\n    address _keeper\n  ) external {\n    require(\n      msg.sender == controllerContracts[_contractName],\n      \"Can only be called by the controlling contract\"\n    );\n\n    Incentive memory incentive = incentives[_contractName][_i];\n\n    if (!incentive.openToEveryone) {\n      IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\")))\n        .requireRole(keccak256(\"Keeper\"), _keeper);\n      require(\n        IStaking(contractRegistry.getContract(keccak256(\"Staking\"))).balanceOf(\n          _keeper\n        ) >= requiredKeeperStake,\n        \"not enough pop at stake\"\n      );\n    }\n    if (incentive.enabled && incentive.reward <= incentiveBudget) {\n      incentiveBudget = incentiveBudget - incentive.reward;\n      uint256 amountToBurn = (incentive.reward * burnRate) / 1e18;\n      uint256 incentivePayout = incentive.reward - amountToBurn;\n      IERC20(contractRegistry.getContract(keccak256(\"POP\"))).safeTransfer(\n        _keeper,\n        incentivePayout\n      );\n      _burn(amountToBurn);\n    }\n  }\n\n  /* ========== SETTER ========== */\n\n  /**\n   * @notice Create Incentives for keeper to call a function\n   * @param _contractName Name of contract that uses ParticipationRewards in bytes32\n   * @param _reward The amount in POP the Keeper receives for calling the function\n   * @param _enabled Is this Incentive currently enabled?\n   * @param _openToEveryone Can anyone call the function for rewards or only keeper?\n   * @dev This function is only for creating unique incentives for future contracts\n   * @dev Multiple functions can use the same incentive which can than be updated with one governance vote\n   */\n  function createIncentive(\n    bytes32 _contractName,\n    uint256 _reward,\n    bool _enabled,\n    bool _openToEveryone\n  ) public {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\")))\n      .requireRole(keccak256(\"DAO\"), msg.sender);\n    incentives[_contractName].push(\n      Incentive({\n        reward: _reward,\n        enabled: _enabled,\n        openToEveryone: _openToEveryone\n      })\n    );\n    emit IncentiveCreated(_contractName, _reward, _openToEveryone);\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  function updateIncentive(\n    bytes32 _contractName,\n    uint8 _i,\n    uint256 _reward,\n    bool _enabled,\n    bool _openToEveryone\n  ) external {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\")))\n      .requireRole(keccak256(\"DAO\"), msg.sender);\n    Incentive storage incentive = incentives[_contractName][_i];\n    uint256 oldReward = incentive.reward;\n    bool oldOpenToEveryone = incentive.openToEveryone;\n    incentive.reward = _reward;\n    incentive.enabled = _enabled;\n    incentive.openToEveryone = _openToEveryone;\n    emit IncentiveChanged(\n      _contractName,\n      oldReward,\n      _reward,\n      oldOpenToEveryone,\n      _openToEveryone\n    );\n  }\n\n  function toggleApproval(bytes32 _contractName, uint8 _i) external {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\")))\n      .requireRole(keccak256(\"DAO\"), msg.sender);\n    Incentive storage incentive = incentives[_contractName][_i];\n    incentive.openToEveryone = !incentive.openToEveryone;\n    emit ApprovalToggled(_contractName, incentive.openToEveryone);\n  }\n\n  function toggleIncentive(bytes32 _contractName, uint8 _i) external {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\")))\n      .requireRole(keccak256(\"DAO\"), msg.sender);\n    Incentive storage incentive = incentives[_contractName][_i];\n    incentive.enabled = !incentive.enabled;\n    emit IncentiveToggled(_contractName, incentive.enabled);\n  }\n\n  function fundIncentive(uint256 _amount) external {\n    IERC20(contractRegistry.getContract(keccak256(\"POP\"))).safeTransferFrom(\n      msg.sender,\n      address(this),\n      _amount\n    );\n    incentiveBudget = incentiveBudget + _amount;\n    emit IncentiveFunded(_amount);\n  }\n\n  /**\n   * @notice In order to allow a contract to use ParticipationReward they need to be added as a controller contract\n   * @param _contractName the name of the controller contract in bytes32\n   * @param contract_ the address of the controller contract\n   * @dev all critical functions to init/open vaults and add shares to them can only be called by controller contracts\n   */\n  function addControllerContract(bytes32 _contractName, address contract_)\n    external\n  {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\")))\n      .requireRole(keccak256(\"DAO\"), msg.sender);\n    controllerContracts[_contractName] = contract_;\n    emit ControllerContractAdded(_contractName, contract_);\n  }\n\n  /**\n   * @notice Sets the current burn rate as a percentage of the incentive reward.\n   * @param _burnRate Percentage in Mantissa. (1e14 = 1 Basis Point)\n   */\n  function updateBurnRate(uint256 _burnRate) external {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\")))\n      .requireRole(keccak256(\"DAO\"), msg.sender);\n    emit BurnRateChanged(burnRate, _burnRate);\n    burnRate = _burnRate;\n  }\n\n  function _burn(uint256 _amount) internal {\n    IERC20(contractRegistry.getContract(keccak256(\"POP\"))).transfer(\n      burnAddress,\n      _amount\n    );\n    emit Burned(_amount);\n  }\n\n  /**\n   * @notice Sets the required amount of POP a keeper needs to have staked to handle incentivized functions.\n   * @param _amount Amount of POP a keeper needs to stake\n   */\n  function updateRequiredKeeperStake(uint256 _amount) external {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\")))\n      .requireRole(keccak256(\"DAO\"), msg.sender);\n    emit RequiredKeeperStakeChanged(requiredKeeperStake, _amount);\n    requiredKeeperStake = _amount;\n  }\n}\n"
    },
    "contracts/core/dao/RewardsEscrow.sol": {
      "content": "// Docgen-SOLC: 0.8.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IStaking.sol\";\nimport \"../interfaces/IRewardsEscrow.sol\";\n\ncontract RewardsEscrow is IRewardsEscrow, ReentrancyGuard, Ownable {\n  using SafeERC20 for IERC20;\n\n  /* ========== STATE VARIABLES ========== */\n  struct Escrow {\n    uint256 start;\n    uint256 end;\n    uint256 balance;\n    address account;\n  }\n\n  IERC20 public immutable POP;\n  mapping(address => bool) public staking;\n  mapping(bytes32 => Escrow) public escrows;\n  mapping(address => bytes32[]) public escrowIdsByAddress;\n  uint256 public escrowDuration = 365 days;\n  uint256 internal nonce;\n\n  /* ========== EVENTS ========== */\n  event Locked(address account, uint256 amount);\n  event RewardsClaimed(address account, uint256 amount);\n  event EscrowDurationChanged(uint256 escrowDuration);\n  event TokenAdded(address token, uint256 index);\n  event AddStaking(address _contract);\n  event RemoveStaking(address _contract);\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(IERC20 _pop) {\n    POP = _pop;\n  }\n\n  /* ========== VIEWS ========== */\n\n  /**\n   * @notice Returns whether the escrow is claimable\n   * @param _escrowId Bytes32 escrow ID\n   */\n  function isClaimable(bytes32 _escrowId) external view returns (bool) {\n    return escrows[_escrowId].start != 0 && escrows[_escrowId].balance > 0;\n  }\n\n  /**\n   * @notice Returns all escrowIdsByAddress which an account has/had claims in\n   * @param _account address\n   */\n  function getEscrowIdsByUser(address _account) external view returns (bytes32[] memory) {\n    return escrowIdsByAddress[_account];\n  }\n\n  /**\n   * @notice Returns an array of Escrows\n   * @param _escrowIds array of escrow ids\n   * @dev there is no check to ensure that all escrows are owned by the same account. Make sure to account for this either by only sending ids for a specific account or by filtering the Escrows by account later on.\n   */\n  function getEscrows(bytes32[] calldata _escrowIds) external view returns (Escrow[] memory) {\n    require(_escrowIds.length <= 20, \"too many ids\");\n\n    Escrow[] memory selectedEscrows = new Escrow[](_escrowIds.length);\n    for (uint256 i = 0; i < _escrowIds.length; i++) {\n      selectedEscrows[i] = escrows[_escrowIds[i]];\n    }\n    return selectedEscrows;\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @notice Locks funds for escrow\n   * @dev This creates a separate escrow structure which can later be iterated upon to unlock the escrowed funds\n   */\n  function lock(address _account, uint256 _amount) external override nonReentrant {\n    require(staking[msg.sender], \"unauthorized\");\n    require(_amount > 0, \"amount must be greater than 0\");\n    require(POP.balanceOf(msg.sender) >= _amount, \"insufficient balance\");\n\n    nonce++;\n    uint256 start = block.timestamp;\n    uint256 end = start + escrowDuration;\n    bytes32 id = keccak256(abi.encodePacked(_account, _amount, start, nonce));\n\n    escrows[id] = Escrow({start: start, end: end, balance: _amount, account: _account});\n    escrowIdsByAddress[_account].push(id);\n\n    POP.safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Locked(_account, _amount);\n  }\n\n  /**\n   * @notice Claim vested funds in escrow\n   * @dev Uses the escrowId at the specified index of escrowIdsByAddress.\n   * @dev This function is used when a user only wants to claim a specific escrowVault or if they decide the gas cost of claimRewards is too high for now.\n   * @dev (lower cost but also lower reward)\n   */\n  function claimReward(bytes32 _escrowId) external nonReentrant {\n    Escrow memory escrow = escrows[_escrowId];\n    require(msg.sender == escrow.account, \"unauthorized\");\n    uint256 reward = _claimReward(_escrowId);\n    require(reward > 0, \"no rewards\");\n\n    POP.safeTransfer(msg.sender, reward);\n\n    emit RewardsClaimed(msg.sender, reward);\n  }\n\n  /**\n   * @notice Claim rewards for multiple escrows\n   * @dev Uses the vaultIds at the specified indices of escrowIdsByAddress.\n   * @dev This function is used when a user wants to claim multiple escrowVaults at once (probably most of the time)\n   * @dev The array of indices is limited to 20 as we want to prevent gas overflow of looping through too many vaults\n   * TODO the upper bound of indices that can be used should be calculated with a simulation\n   */\n  function claimRewards(bytes32[] calldata _escrowIdsByAddress) external nonReentrant {\n    require(_escrowIdsByAddress.length <= 20, \"claiming too many escrows\");\n    uint256 total;\n\n    for (uint256 i = 0; i < _escrowIdsByAddress.length; i++) {\n      bytes32 _escrowId = _escrowIdsByAddress[i];\n      Escrow memory escrow = escrows[_escrowId];\n      require(msg.sender == escrow.account, \"unauthorized\");\n      uint256 reward = _claimReward(_escrowId);\n      total += reward;\n    }\n    require(total > 0, \"no rewards\");\n\n    POP.safeTransfer(msg.sender, total);\n\n    emit RewardsClaimed(msg.sender, total);\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  function updateEscrowDuration(uint256 _escrowDuration) external onlyOwner {\n    escrowDuration = _escrowDuration;\n    emit EscrowDurationChanged(_escrowDuration);\n  }\n\n  function addStakingContract(address _staking) external onlyOwner {\n    staking[_staking] = true;\n    emit AddStaking(_staking);\n  }\n\n  function removeStakingContract(address _staking) external onlyOwner {\n    delete staking[_staking];\n    emit RemoveStaking(_staking);\n  }\n\n  /**\n   * @notice Underlying function to calculate the rewards that a user gets\n   * @dev We dont want it to error when a vault is empty for the user as this would terminate the entire loop when used in claimRewards()\n   */\n  function _claimReward(bytes32 _escrowId) internal returns (uint256) {\n    Escrow storage escrow = escrows[_escrowId];\n    if (escrow.start <= block.timestamp) {\n      uint256 claimable = _getClaimableAmount(escrow);\n      escrow.balance -= claimable;\n      return claimable;\n    }\n    return 0;\n  }\n\n  function _getClaimableAmount(Escrow memory _escrow) internal view returns (uint256) {\n    if (_escrow.start == 0 || _escrow.end == 0) {\n      return 0;\n    }\n    return\n      Math.min((_escrow.balance * (block.timestamp - _escrow.start)) / (_escrow.end - _escrow.start), _escrow.balance);\n  }\n}\n"
    },
    "contracts/core/tokens/XPop.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\ncontract XPop is\n  Ownable,\n  ERC20(\"Popcorn.Network (Redeemable POP)\", \"xPOP\"),\n  ERC20Burnable,\n  ERC20Permit(\"Popcorn.Network (Redeemable POP)\")\n{\n  uint256 private immutable _mintCap;\n  uint256 private _totalMinted;\n\n  constructor(uint256 mintCap_) {\n    require(mintCap_ > 0, \"Mint cap is 0\");\n    _mintCap = mintCap_;\n  }\n\n  function mint(address to, uint256 amount) public onlyOwner {\n    _mint(to, amount);\n  }\n\n  function totalMinted() public view returns (uint256) {\n    return _totalMinted;\n  }\n\n  function mintCap() public view returns (uint256) {\n    return _mintCap;\n  }\n\n  function _mint(address to, uint256 amount) internal override {\n    require(_totalMinted + amount <= mintCap(), \"Mint cap exceeded\");\n    _totalMinted += amount;\n    super._mint(to, amount);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/core/utils/Superseeder.sol": {
      "content": "pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Superseeder {\n  function seed(\n    ERC20 erc20,\n    address[] calldata receivers,\n    uint256[] calldata amounts\n  ) external {\n    for (uint256 i = 0; i < receivers.length; i++) {\n      erc20.transferFrom(msg.sender, receivers[i], amounts[i]);\n    }\n  }\n}\n"
    },
    "contracts/core/defi/butter/ButterBatchProcessing.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"../../interfaces/IACLRegistry.sol\";\nimport \"../../../externals/interfaces/YearnVault.sol\";\nimport \"../../../externals/interfaces/BasicIssuanceModule.sol\";\nimport \"../../../externals/interfaces/ISetToken.sol\";\nimport \"../../../externals/interfaces/CurveContracts.sol\";\nimport \"../../interfaces/IContractRegistry.sol\";\nimport \"../../utils/KeeperIncentive.sol\";\n\n/*\nThis Contract allows smaller depositors to mint and redeem HYSI without needing to through all the steps necessary on their own...\n...which not only takes long but mainly costs enormous amounts of gas.\nThe HYSI is created from 4 different yToken which in turn need each a deposit of a crvLPToken.\nThis means 12 approvals and 9 deposits are necessary to mint one HYSI.\nWe Batch this process and allow users to pool their funds. Than we pay keeper to Mint or Redeem HYSI regularly.\n*/\ncontract ButterBatchProcessing is Pausable {\n  using SafeERC20 for YearnVault;\n  using SafeERC20 for ISetToken;\n  using SafeERC20 for IERC20;\n\n  /**\n   * @notice Defines if the Batch will mint or redeem HYSI\n   */\n  enum BatchType {\n    Mint,\n    Redeem\n  }\n\n  /**\n   * @notice Defines if the Batch will mint or redeem HYSI\n   * @param curveMetaPool A CurveMetaPool for trading an exotic stablecoin against 3CRV\n   * @param crvLPToken The LP-Token of the CurveMetapool\n   */\n  struct CurvePoolTokenPair {\n    CurveMetapool curveMetaPool;\n    IERC20 crvLPToken;\n  }\n\n  /**\n   * @notice The Batch structure is used both for Batches of Minting and Redeeming\n   * @param batchType Determines if this Batch is for Minting or Redeeming HYSI\n   * @param batchId bytes32 id of the batch\n   * @param claimable Shows if a batch has been processed and is ready to be claimed, the suppliedToken cant be withdrawn if a batch is claimable\n   * @param unclaimedShares The total amount of unclaimed shares in this batch\n   * @param suppliedTokenBalance The total amount of deposited token (either 3CRV or HYSI)\n   * @param claimableTokenBalance The total amount of claimable token (either 3CRV or HYSI)\n   * @param tokenAddress The address of the the token to be claimed\n   * @param shareBalance The individual share balance per user that has deposited token\n   */\n  struct Batch {\n    BatchType batchType;\n    bytes32 batchId;\n    bool claimable;\n    uint256 unclaimedShares;\n    uint256 suppliedTokenBalance;\n    uint256 claimableTokenBalance;\n    address suppliedTokenAddress;\n    address claimableTokenAddress;\n  }\n\n  /* ========== STATE VARIABLES ========== */\n\n  bytes32 public immutable contractName = \"ButterBatchProcessing\";\n\n  IContractRegistry public contractRegistry;\n  ISetToken public setToken;\n  IERC20 public threeCrv;\n  BasicIssuanceModule public setBasicIssuanceModule;\n  mapping(address => CurvePoolTokenPair) public curvePoolTokenPairs;\n\n  /**\n   * @notice This maps batch ids to addresses with share balances\n   */\n  mapping(bytes32 => mapping(address => uint256)) public accountBalances;\n  mapping(address => bytes32[]) public accountBatches;\n  mapping(bytes32 => Batch) public batches;\n  bytes32[] public batchIds;\n\n  uint256 public lastMintedAt;\n  uint256 public lastRedeemedAt;\n  bytes32 public currentMintBatchId;\n  bytes32 public currentRedeemBatchId;\n  uint256 public batchCooldown;\n  uint256 public mintThreshold;\n  uint256 public redeemThreshold;\n\n  /* ========== EVENTS ========== */\n\n  event Deposit(address indexed from, uint256 deposit);\n  event Withdrawal(address indexed to, uint256 amount);\n  event BatchMinted(bytes32 indexed batchId, uint256 suppliedTokenAmount, uint256 hysiAmount);\n  event BatchRedeemed(bytes32 indexed batchId, uint256 suppliedTokenAmount, uint256 threeCrvAmount);\n  event Claimed(address indexed account, BatchType batchType, uint256 shares, uint256 claimedToken);\n  event TokenSetAdded(ISetToken setToken);\n  event WithdrawnFromBatch(bytes32 batchId, uint256 amount, address to);\n  event MovedUnclaimedDepositsIntoCurrentBatch(uint256 amount, BatchType batchType, address account);\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    IContractRegistry _contractRegistry,\n    ISetToken _setToken,\n    IERC20 _threeCrv,\n    BasicIssuanceModule _basicIssuanceModule,\n    address[] memory _yTokenAddresses,\n    CurvePoolTokenPair[] memory _curvePoolTokenPairs,\n    uint256 _batchCooldown,\n    uint256 _mintThreshold,\n    uint256 _redeemThreshold\n  ) {\n    contractRegistry = _contractRegistry;\n    setToken = _setToken;\n    threeCrv = _threeCrv;\n    setBasicIssuanceModule = _basicIssuanceModule;\n\n    _setCurvePoolTokenPairs(_yTokenAddresses, _curvePoolTokenPairs);\n\n    batchCooldown = _batchCooldown;\n    mintThreshold = _mintThreshold;\n    redeemThreshold = _redeemThreshold;\n    lastMintedAt = block.timestamp;\n    lastRedeemedAt = block.timestamp;\n\n    _generateNextBatch(bytes32(\"mint\"), BatchType.Mint);\n    _generateNextBatch(bytes32(\"redeem\"), BatchType.Redeem);\n  }\n\n  /* ========== VIEWS ========== */\n  /**\n   * @notice Get ids for all batches that a user has interacted with\n   * @param _account The address for whom we want to retrieve batches\n   */\n  function getAccountBatches(address _account) external view returns (bytes32[] memory) {\n    return accountBatches[_account];\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @notice Deposits funds in the current mint batch\n   * @param _amount Amount of 3cr3CRV to use for minting\n   * @param _depositFor User that gets the shares attributed to (for use in zapper contract)\n   * @dev Should this be secured we nonReentrant?\n   */\n  function depositForMint(uint256 _amount, address _depositFor) external whenNotPaused {\n    require(\n      IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\"))).hasRole(\n        keccak256(\"ButterZapper\"),\n        msg.sender\n      ) || msg.sender == _depositFor,\n      \"you cant transfer other funds\"\n    );\n    require(threeCrv.balanceOf(msg.sender) >= _amount, \"insufficent balance\");\n    threeCrv.transferFrom(msg.sender, address(this), _amount);\n    _deposit(_amount, currentMintBatchId, _depositFor);\n  }\n\n  /**\n   * @notice deposits funds in the current redeem batch\n   * @param _amount amount of HYSI to be redeemed\n   * @dev Should this be secured we nonReentrant?\n   */\n  function depositForRedeem(uint256 _amount) external whenNotPaused {\n    require(setToken.balanceOf(msg.sender) >= _amount, \"insufficient balance\");\n    setToken.transferFrom(msg.sender, address(this), _amount);\n    _deposit(_amount, currentRedeemBatchId, msg.sender);\n  }\n\n  /**\n   * @notice This function allows a user to withdraw their funds from a batch before that batch has been processed\n   * @param _batchId From which batch should funds be withdrawn from\n   * @param _amountToWithdraw Amount of HYSI or 3CRV to be withdrawn from the queue (depending on mintBatch / redeemBatch)\n   * @param _withdrawFor User that gets the shares attributed to (for use in zapper contract)\n   */\n  function withdrawFromBatch(\n    bytes32 _batchId,\n    uint256 _amountToWithdraw,\n    address _withdrawFor\n  ) external {\n    address recipient = _getRecipient(_withdrawFor);\n\n    Batch storage batch = batches[_batchId];\n    uint256 accountBalance = accountBalances[_batchId][_withdrawFor];\n    require(batch.claimable == false, \"already processed\");\n    require(accountBalance >= _amountToWithdraw, \"account has insufficient funds\");\n\n    //At this point the share balance is equal to the supplied token and can be used interchangeably\n    accountBalances[_batchId][_withdrawFor] = accountBalance - _amountToWithdraw;\n    batch.suppliedTokenBalance = batch.suppliedTokenBalance - _amountToWithdraw;\n    batch.unclaimedShares = batch.unclaimedShares - _amountToWithdraw;\n\n    if (batch.batchType == BatchType.Mint) {\n      threeCrv.safeTransfer(recipient, _amountToWithdraw);\n    } else {\n      setToken.safeTransfer(recipient, _amountToWithdraw);\n    }\n    emit WithdrawnFromBatch(_batchId, _amountToWithdraw, _withdrawFor);\n  }\n\n  /**\n   * @notice Claims funds after the batch has been processed (get HYSI from a mint batch and 3CRV from a redeem batch)\n   * @param _batchId Id of batch to claim from\n   * @param _claimFor User that gets the shares attributed to (for use in zapper contract)\n   */\n  function claim(bytes32 _batchId, address _claimFor) external returns (uint256) {\n    Batch storage batch = batches[_batchId];\n    require(batch.claimable, \"not yet claimable\");\n\n    address recipient = _getRecipient(_claimFor);\n    uint256 accountBalance = accountBalances[_batchId][_claimFor];\n    require(accountBalance <= batch.unclaimedShares, \"claiming too many shares\");\n\n    //Calculate how many token will be claimed\n    uint256 tokenAmountToClaim = (batch.claimableTokenBalance * accountBalance) / batch.unclaimedShares;\n\n    //Subtract the claimed token from the batch\n    batch.claimableTokenBalance = batch.claimableTokenBalance - tokenAmountToClaim;\n    batch.unclaimedShares = batch.unclaimedShares - accountBalance;\n    accountBalances[_batchId][_claimFor] = 0;\n\n    //Transfer token\n    if (batch.batchType == BatchType.Mint) {\n      setToken.safeTransfer(recipient, tokenAmountToClaim);\n    } else {\n      threeCrv.safeTransfer(recipient, tokenAmountToClaim);\n    }\n\n    emit Claimed(_claimFor, batch.batchType, accountBalance, tokenAmountToClaim);\n\n    return tokenAmountToClaim;\n  }\n\n  /**\n   * @notice Moves unclaimed token (3crv or Hysi) from their respective Batches into a new redeemBatch / mintBatch without needing to claim them first. This will typically be used when hysi has already been minted and a user has never claimed / transfered the token to their address and they would like to convert it to stablecoin.\n   * @param _batchIds the ids of each batch where hysi should be moved from\n   * @param _shares how many shares should redeemed in each of the batches\n   * @param _batchType the batchType where funds should be taken from (Mint -> Take Hysi and redeem then, Redeem -> Take 3Crv and Mint HYSI)\n   * @dev the indices of batchIds must match the amountsInHysi to work properly (This will be done by the frontend)\n   */\n  function moveUnclaimedDepositsIntoCurrentBatch(\n    bytes32[] calldata _batchIds,\n    uint256[] calldata _shares,\n    BatchType _batchType\n  ) external whenNotPaused {\n    require(_batchIds.length == _shares.length, \"array lengths must match\");\n\n    uint256 totalAmount;\n\n    for (uint256 i; i < _batchIds.length; i++) {\n      Batch storage batch = batches[_batchIds[i]];\n      uint256 accountBalance = accountBalances[batch.batchId][msg.sender];\n      //Check that the user has enough funds and that the batch was already minted\n      //Only the current redeemBatch is claimable == false so this check allows us to not adjust batch.suppliedTokenBalance\n      //Additionally it makes no sense to move funds from the current redeemBatch to the current redeemBatch\n      require(batch.claimable == true, \"has not yet been processed\");\n      require(batch.batchType == _batchType, \"incorrect batchType\");\n      require(accountBalance >= _shares[i], \"account has insufficient funds\");\n\n      uint256 tokenAmountToClaim = (batch.claimableTokenBalance * _shares[i]) / batch.unclaimedShares;\n      batch.claimableTokenBalance = batch.claimableTokenBalance - tokenAmountToClaim;\n      batch.unclaimedShares = batch.unclaimedShares - _shares[i];\n      accountBalances[batch.batchId][msg.sender] = accountBalance - _shares[i];\n\n      totalAmount = totalAmount + tokenAmountToClaim;\n    }\n    require(totalAmount > 0, \"totalAmount must be larger 0\");\n\n    if (BatchType.Mint == _batchType) {\n      _deposit(totalAmount, currentRedeemBatchId, msg.sender);\n    }\n\n    if (BatchType.Redeem == _batchType) {\n      _deposit(totalAmount, currentMintBatchId, msg.sender);\n    }\n\n    emit MovedUnclaimedDepositsIntoCurrentBatch(totalAmount, _batchType, msg.sender);\n  }\n\n  /**\n   * @notice Mint HYSI token with deposited 3CRV. This function goes through all the steps necessary to mint an optimal amount of HYSI\n   * @param _minAmountToMint The expected min amount of hysi to mint. If hysiAmount is lower than minAmountToMint_ the transaction will revert.\n   * @dev This function deposits 3CRV in the underlying Metapool and deposits these LP token to get yToken which in turn are used to mint HYSI\n   * @dev This process leaves some leftovers which are partially used in the next mint batches.\n   * @dev In order to get 3CRV we can implement a zap to move stables into the curve tri-pool\n   * @dev handleKeeperIncentive checks if the msg.sender is a permissioned keeper and pays them a reward for calling this function (see KeeperIncentive.sol)\n   */\n  function batchMint(uint256 _minAmountToMint) external whenNotPaused {\n    KeeperIncentive(contractRegistry.getContract(keccak256(\"KeeperIncentive\"))).handleKeeperIncentive(\n      contractName,\n      0,\n      msg.sender\n    );\n    Batch storage batch = batches[currentMintBatchId];\n\n    //Check if there was enough time between the last batch minting and this attempt...\n    //...or if enough 3CRV was deposited to make the minting worthwhile\n    //This is to prevent excessive gas consumption and costs as we will pay keeper to call this function\n    require(\n      (block.timestamp - lastMintedAt) >= batchCooldown || (batch.suppliedTokenBalance >= mintThreshold),\n      \"can not execute batch action yet\"\n    );\n\n    //Check if the Batch got already processed -- should technically not be possible\n    require(batch.claimable == false, \"already minted\");\n\n    //Check if this contract has enough 3CRV -- should technically not be necessary\n    require(\n      threeCrv.balanceOf(address(this)) >= batch.suppliedTokenBalance,\n      \"account has insufficient balance of token to mint\"\n    );\n\n    //Get the quantity of yToken for one HYSI\n    (address[] memory tokenAddresses, uint256[] memory quantities) = setBasicIssuanceModule\n      .getRequiredComponentUnitsForIssue(setToken, 1e18);\n\n    //Total value of leftover yToken valued in 3CRV\n    uint256 totalLeftoverIn3Crv;\n\n    //Individual yToken leftovers valued in 3CRV\n    uint256[] memory leftoversIn3Crv = new uint256[](quantities.length);\n\n    for (uint256 i; i < tokenAddresses.length; i++) {\n      //Check how many crvLPToken are needed to mint one yToken\n      uint256 yTokenInCrvToken = YearnVault(tokenAddresses[i]).pricePerShare();\n\n      //Check how many 3CRV are needed to mint one crvLPToken\n      uint256 crvLPTokenIn3Crv = uint256(2e18) -\n        curvePoolTokenPairs[tokenAddresses[i]].curveMetaPool.calc_withdraw_one_coin(1e18, 1);\n\n      //Calculate how many 3CRV are needed to mint one yToken\n      uint256 yTokenIn3Crv = (yTokenInCrvToken * crvLPTokenIn3Crv) / 1e18;\n\n      //Calculate how much the yToken leftover are worth in 3CRV\n      uint256 leftoverIn3Crv = (YearnVault(tokenAddresses[i]).balanceOf(address(this)) * yTokenIn3Crv) / 1e18;\n\n      //Add the leftover value to the array of leftovers for later use\n      leftoversIn3Crv[i] = leftoverIn3Crv;\n\n      //Add the leftover value to the total leftover value\n      totalLeftoverIn3Crv = totalLeftoverIn3Crv + leftoverIn3Crv;\n    }\n\n    //Calculate the total value of supplied token + leftovers in 3CRV\n    uint256 suppliedTokenBalancePlusLeftovers = batch.suppliedTokenBalance + totalLeftoverIn3Crv;\n\n    for (uint256 i; i < tokenAddresses.length; i++) {\n      //Calculate the pool allocation by dividing the suppliedTokenBalance by 4 and take leftovers into account\n      uint256 poolAllocation = suppliedTokenBalancePlusLeftovers / 4 - leftoversIn3Crv[i];\n\n      //Pool 3CRV to get crvLPToken\n      _sendToCurve(poolAllocation, curvePoolTokenPairs[tokenAddresses[i]].curveMetaPool);\n\n      //Deposit crvLPToken to get yToken\n      _sendToYearn(\n        curvePoolTokenPairs[tokenAddresses[i]].crvLPToken.balanceOf(address(this)),\n        curvePoolTokenPairs[tokenAddresses[i]].crvLPToken,\n        YearnVault(tokenAddresses[i])\n      );\n\n      //Approve yToken for minting\n      YearnVault(tokenAddresses[i]).safeIncreaseAllowance(\n        address(setBasicIssuanceModule),\n        YearnVault(tokenAddresses[i]).balanceOf(address(this))\n      );\n    }\n\n    //Get the minimum amount of hysi that we can mint with our balances of yToken\n    uint256 hysiAmount = (YearnVault(tokenAddresses[0]).balanceOf(address(this)) * 1e18) / quantities[0];\n\n    for (uint256 i = 1; i < tokenAddresses.length; i++) {\n      hysiAmount = Math.min(\n        hysiAmount,\n        (YearnVault(tokenAddresses[i]).balanceOf(address(this)) * 1e18) / quantities[i]\n      );\n    }\n\n    require(hysiAmount >= _minAmountToMint, \"slippage too high\");\n\n    //Mint HYSI\n    setBasicIssuanceModule.issue(setToken, hysiAmount, address(this));\n\n    //Save the minted amount HYSI as claimable token for the batch\n    batch.claimableTokenBalance = hysiAmount;\n\n    //Set claimable to true so users can claim their HYSI\n    batch.claimable = true;\n\n    //Update lastMintedAt for cooldown calculations\n    lastMintedAt = block.timestamp;\n\n    emit BatchMinted(currentMintBatchId, batch.suppliedTokenBalance, hysiAmount);\n\n    //Create the next mint batch\n    _generateNextBatch(currentMintBatchId, BatchType.Mint);\n  }\n\n  /**\n   * @notice Redeems HYSI for 3CRV. This function goes through all the steps necessary to get 3CRV\n   * @param _min3crvToReceive sets minimum amount of 3crv to redeem HYSI for, otherwise the transaction will revert\n   * @dev This function reedeems HYSI for the underlying yToken and deposits these yToken in curve Metapools for 3CRV\n   * @dev In order to get stablecoins from 3CRV we can use a zap to redeem 3CRV for stables in the curve tri-pool\n   * @dev handleKeeperIncentive checks if the msg.sender is a permissioned keeper and pays them a reward for calling this function (see KeeperIncentive.sol)\n   */\n  function batchRedeem(uint256 _min3crvToReceive) external whenNotPaused {\n    KeeperIncentive(contractRegistry.getContract(keccak256(\"KeeperIncentive\"))).handleKeeperIncentive(\n      contractName,\n      1,\n      msg.sender\n    );\n    Batch storage batch = batches[currentRedeemBatchId];\n\n    //Check if there was enough time between the last batch redemption and this attempt...\n    //...or if enough HYSI was deposited to make the redemption worthwhile\n    //This is to prevent excessive gas consumption and costs as we will pay keeper to call this function\n    require(\n      (block.timestamp - lastRedeemedAt >= batchCooldown) || (batch.suppliedTokenBalance >= redeemThreshold),\n      \"can not execute batch action yet\"\n    );\n    //Check if the Batch got already processed -- should technically not be possible\n    require(batch.claimable == false, \"already redeemed\");\n\n    //Check if this contract has enough HYSI -- should technically not be necessary\n    require(\n      setToken.balanceOf(address(this)) >= batch.suppliedTokenBalance,\n      \"contract has insufficient balance of token to redeem\"\n    );\n\n    //Get tokenAddresses for mapping of underlying\n    (address[] memory tokenAddresses, uint256[] memory quantities) = setBasicIssuanceModule\n      .getRequiredComponentUnitsForIssue(setToken, 1e18);\n\n    //Allow setBasicIssuanceModule to use HYSI\n    setToken.safeIncreaseAllowance(address(setBasicIssuanceModule), batch.suppliedTokenBalance);\n\n    //Redeem HYSI for yToken\n    setBasicIssuanceModule.redeem(setToken, batch.suppliedTokenBalance, address(this));\n\n    //Check our balance of 3CRV since we could have some still around from previous batches\n    uint256 oldBalance = threeCrv.balanceOf(address(this));\n\n    for (uint256 i; i < tokenAddresses.length; i++) {\n      //Deposit yToken to receive crvLPToken\n      _withdrawFromYearn(YearnVault(tokenAddresses[i]).balanceOf(address(this)), YearnVault(tokenAddresses[i]));\n\n      uint256 crvLPTokenBalance = curvePoolTokenPairs[tokenAddresses[i]].crvLPToken.balanceOf(address(this));\n\n      //Deposit crvLPToken to receive 3CRV\n      _withdrawFromCurve(\n        crvLPTokenBalance,\n        curvePoolTokenPairs[tokenAddresses[i]].crvLPToken,\n        curvePoolTokenPairs[tokenAddresses[i]].curveMetaPool\n      );\n    }\n\n    //Save the redeemed amount of 3CRV as claimable token for the batch\n    batch.claimableTokenBalance = threeCrv.balanceOf(address(this)) - oldBalance;\n\n    require(batch.claimableTokenBalance >= _min3crvToReceive, \"slippage too high\");\n\n    emit BatchRedeemed(currentRedeemBatchId, batch.suppliedTokenBalance, batch.claimableTokenBalance);\n\n    //Set claimable to true so users can claim their HYSI\n    batch.claimable = true;\n\n    //Update lastRedeemedAt for cooldown calculations\n    lastRedeemedAt = block.timestamp;\n\n    //Create the next redeem batch id\n    _generateNextBatch(currentRedeemBatchId, BatchType.Redeem);\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /**\n   * @notice makes sure only zapper or user can withdraw from accout_ and returns the recipient of the withdrawn token\n   * @param _account is the address which gets withdrawn from\n   * @dev returns recipient of the withdrawn funds\n   * @dev By default a user should set _account to their address\n   * @dev If zapper is used to withdraw and swap for a user the msg.sender will be zapper and _account is the user which we withdraw from. The zapper than sends the swapped funds afterwards to the user\n   */\n  function _getRecipient(address _account) internal returns (address) {\n    //Make sure that only zapper can withdraw from someone else\n    require(\n      IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\"))).hasRole(\n        keccak256(\"ButterZapper\"),\n        msg.sender\n      ) || msg.sender == _account,\n      \"you cant transfer other funds\"\n    );\n\n    //Set recipient per default to _account\n    address recipient = _account;\n\n    //set the recipient to zapper if its called by the zapper\n    if (\n      IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\"))).hasRole(\n        keccak256(\"ButterZapper\"),\n        msg.sender\n      )\n    ) {\n      recipient = msg.sender;\n    }\n    return recipient;\n  }\n\n  /**\n   * @notice Generates the next batch id for new deposits\n   * @param _currentBatchId takes the current mint or redeem batch id\n   * @param _batchType BatchType of the newly created id\n   */\n  function _generateNextBatch(bytes32 _currentBatchId, BatchType _batchType) internal returns (bytes32) {\n    bytes32 id = _generateNextBatchId(_currentBatchId);\n    batchIds.push(id);\n    Batch storage batch = batches[id];\n    batch.batchType = _batchType;\n    batch.batchId = id;\n\n    if (BatchType.Mint == _batchType) {\n      currentMintBatchId = id;\n      batch.suppliedTokenAddress = address(threeCrv);\n      batch.claimableTokenAddress = address(setToken);\n    }\n    if (BatchType.Redeem == _batchType) {\n      currentRedeemBatchId = id;\n      batch.suppliedTokenAddress = address(setToken);\n      batch.claimableTokenAddress = address(threeCrv);\n    }\n    return id;\n  }\n\n  /**\n   * @notice Deposit either HYSI or 3CRV in their respective batches\n   * @param _amount The amount of 3CRV or HYSI a user is depositing\n   * @param _currentBatchId The current reedem or mint batch id to place the funds in the next batch to be processed\n   * @param _depositFor User that gets the shares attributed to (for use in zapper contract)\n   * @dev This function will be called by depositForMint or depositForRedeem and simply reduces code duplication\n   */\n  function _deposit(\n    uint256 _amount,\n    bytes32 _currentBatchId,\n    address _depositFor\n  ) internal {\n    Batch storage batch = batches[_currentBatchId];\n\n    //Add the new funds to the batch\n    batch.suppliedTokenBalance = batch.suppliedTokenBalance + _amount;\n    batch.unclaimedShares = batch.unclaimedShares + _amount;\n    accountBalances[_currentBatchId][_depositFor] = accountBalances[_currentBatchId][_depositFor] + _amount;\n\n    //Save the batchId for the user so they can be retrieved to claim the batch\n    if (\n      accountBatches[_depositFor].length == 0 ||\n      accountBatches[_depositFor][accountBatches[_depositFor].length - 1] != _currentBatchId\n    ) {\n      accountBatches[_depositFor].push(_currentBatchId);\n    }\n\n    emit Deposit(_depositFor, _amount);\n  }\n\n  /**\n   * @notice Deposit 3CRV in a curve metapool for its LP-Token\n   * @param _amount The amount of 3CRV that gets deposited\n   * @param _curveMetapool The metapool where we want to provide liquidity\n   */\n  function _sendToCurve(uint256 _amount, CurveMetapool _curveMetapool) internal returns (uint256) {\n    uint256 allowanceAmount = threeCrv.allowance(address(this), address(_curveMetapool));\n    threeCrv.safeDecreaseAllowance(address(_curveMetapool), allowanceAmount);\n    threeCrv.safeIncreaseAllowance(address(_curveMetapool), type(uint256).max);\n\n    //Takes 3CRV and sends lpToken to this contract\n    //Metapools take an array of amounts with the exoctic stablecoin at the first spot and 3CRV at the second.\n    //The second variable determines the min amount of LP-Token we want to receive (slippage control)\n    _curveMetapool.add_liquidity([0, _amount], 0);\n  }\n\n  /**\n   * @notice Withdraws 3CRV for deposited crvLPToken\n   * @param _amount The amount of crvLPToken that get deposited\n   * @param _lpToken Which crvLPToken we deposit\n   * @param _curveMetapool The metapool where we want to provide liquidity\n   */\n  function _withdrawFromCurve(\n    uint256 _amount,\n    IERC20 _lpToken,\n    CurveMetapool _curveMetapool\n  ) internal returns (uint256) {\n    uint256 allowanceAmount = _lpToken.allowance(address(this), address(_curveMetapool));\n    _lpToken.safeDecreaseAllowance(address(_curveMetapool), allowanceAmount);\n    _lpToken.safeIncreaseAllowance(address(_curveMetapool), type(uint256).max);\n\n    //Takes lp Token and sends 3CRV to this contract\n    //The second variable is the index for the token we want to receive (0 = exotic stablecoin, 1 = 3CRV)\n    //The third variable determines min amount of token we want to receive (slippage control)\n    _curveMetapool.remove_liquidity_one_coin(_amount, 1, 0);\n  }\n\n  /**\n   * @notice Deposits crvLPToken for yToken\n   * @param _amount The amount of crvLPToken that get deposited\n   * @param _crvLPToken The crvLPToken which we deposit\n   * @param _yearnVault The yearn Vault in which we deposit\n   */\n  function _sendToYearn(\n    uint256 _amount,\n    IERC20 _crvLPToken,\n    YearnVault _yearnVault\n  ) internal {\n    uint256 allowanceAmount = _crvLPToken.allowance(address(this), address(_yearnVault));\n    _crvLPToken.safeDecreaseAllowance(address(_yearnVault), allowanceAmount);\n    _crvLPToken.safeIncreaseAllowance(address(_yearnVault), type(uint256).max);\n\n    //Mints yToken and sends them to msg.sender (this contract)\n    _yearnVault.deposit(_amount);\n  }\n\n  /**\n   * @notice Withdraw crvLPToken from yearn\n   * @param _amount The amount of crvLPToken which we deposit\n   * @param _yearnVault The yearn Vault in which we deposit\n   */\n  function _withdrawFromYearn(uint256 _amount, YearnVault _yearnVault) internal {\n    uint256 allowanceAmount = _yearnVault.allowance(address(this), address(_yearnVault));\n    _yearnVault.safeDecreaseAllowance(address(_yearnVault), allowanceAmount);\n    _yearnVault.safeIncreaseAllowance(address(_yearnVault), type(uint256).max);\n\n    //Takes yToken and sends crvLPToken to this contract\n    _yearnVault.withdraw(_amount);\n  }\n\n  /**\n   * @notice Generates the next batch id for new deposits\n   * @param _currentBatchId takes the current mint or redeem batch id\n   */\n  function _generateNextBatchId(bytes32 _currentBatchId) internal returns (bytes32) {\n    return keccak256(abi.encodePacked(block.timestamp, _currentBatchId));\n  }\n\n  /* ========== ADMIN ========== */\n\n  /**\n   * @notice This function allows the owner to change the composition of underlying token of the HYSI\n   * @param _yTokenAddresses An array of addresses for the yToken needed to mint HYSI\n   * @param _curvePoolTokenPairs An array structs describing underlying yToken, crvToken and curve metapool\n   */\n  function setCurvePoolTokenPairs(address[] memory _yTokenAddresses, CurvePoolTokenPair[] calldata _curvePoolTokenPairs)\n    public\n  {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\"))).requireRole(keccak256(\"DAO\"), msg.sender);\n    _setCurvePoolTokenPairs(_yTokenAddresses, _curvePoolTokenPairs);\n  }\n\n  /**\n   * @notice This function defines which underlying token and pools are needed to mint a hysi token\n   * @param _yTokenAddresses An array of addresses for the yToken needed to mint HYSI\n   * @param _curvePoolTokenPairs An array structs describing underlying yToken, crvToken and curve metapool\n   * @dev since our calculations for minting just iterate through the index and match it with the quantities given by Set\n   * @dev we must make sure to align them correctly by index, otherwise our whole calculation breaks down\n   */\n  function _setCurvePoolTokenPairs(address[] memory _yTokenAddresses, CurvePoolTokenPair[] memory _curvePoolTokenPairs)\n    internal\n  {\n    for (uint256 i; i < _yTokenAddresses.length; i++) {\n      curvePoolTokenPairs[_yTokenAddresses[i]] = _curvePoolTokenPairs[i];\n    }\n  }\n\n  /**\n   * @notice Changes the current batch cooldown\n   * @param _cooldown Cooldown in seconds\n   * @dev The cooldown is the same for redeem and mint batches\n   */\n  function setBatchCooldown(uint256 _cooldown) external {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\"))).requireRole(keccak256(\"DAO\"), msg.sender);\n    batchCooldown = _cooldown;\n  }\n\n  /**\n   * @notice Changes the Threshold of 3CRV which need to be deposited to be able to mint immediately\n   * @param _threshold Amount of 3CRV necessary to mint immediately\n   */\n  function setMintThreshold(uint256 _threshold) external {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\"))).requireRole(keccak256(\"DAO\"), msg.sender);\n    mintThreshold = _threshold;\n  }\n\n  /**\n   * @notice Changes the Threshold of HYSI which need to be deposited to be able to redeem immediately\n   * @param _threshold Amount of HYSI necessary to mint immediately\n   */\n  function setRedeemThreshold(uint256 _threshold) external {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\"))).requireRole(keccak256(\"DAO\"), msg.sender);\n    redeemThreshold = _threshold;\n  }\n\n  /**\n   * @notice Pauses the contract.\n   * @dev All function with the modifer `whenNotPaused` cant be called anymore. Namly deposits and mint/redeem\n   */\n  function pause() external {\n    IACLRegistry(contractRegistry.getContract(keccak256(\"ACLRegistry\"))).requireRole(keccak256(\"DAO\"), msg.sender);\n    _pause();\n  }\n}\n"
    },
    "contracts/externals/interfaces/YearnVault.sol": {
      "content": "pragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface YearnVault is IERC20 {\n  function token() external view returns (address);\n\n  function deposit(uint256 amount) external;\n\n  function withdraw(uint256 amount) external;\n\n  function pricePerShare() external view returns (uint256);\n}\n"
    },
    "contracts/externals/interfaces/BasicIssuanceModule.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"./ISetToken.sol\";\n\ninterface BasicIssuanceModule {\n  function getRequiredComponentUnitsForIssue(\n    ISetToken _setToken,\n    uint256 _quantity\n  ) external view returns (address[] memory, uint256[] memory);\n\n  function issue(\n    ISetToken _setToken,\n    uint256 _quantity,\n    address _to\n  ) external;\n\n  function redeem(\n    ISetToken _setToken,\n    uint256 _quantity,\n    address _to\n  ) external;\n}\n"
    },
    "contracts/externals/interfaces/ISetToken.sol": {
      "content": "/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title ISetToken\n * @author Set Protocol\n *\n * Interface for operating with SetTokens.\n */\ninterface ISetToken is IERC20 {\n  /* ============ Enums ============ */\n\n  enum ModuleState {\n    NONE,\n    PENDING,\n    INITIALIZED\n  }\n\n  /* ============ Structs ============ */\n  /**\n   * The base definition of a SetToken Position\n   *\n   * @param component           Address of token in the Position\n   * @param module              If not in default state, the address of associated module\n   * @param unit                Each unit is the # of components per 10^18 of a SetToken\n   * @param positionState       Position ENUM. Default is 0; External is 1\n   * @param data                Arbitrary data\n   */\n  struct Position {\n    address component;\n    address module;\n    int256 unit;\n    uint8 positionState;\n    bytes data;\n  }\n\n  /**\n   * A struct that stores a component's cash position details and external positions\n   * This data structure allows O(1) access to a component's cash position units and\n   * virtual units.\n   *\n   * @param virtualUnit               Virtual value of a component's DEFAULT position. Stored as virtual for efficiency\n   *                                  updating all units at once via the position multiplier. Virtual units are achieved\n   *                                  by dividing a \"real\" value by the \"positionMultiplier\"\n   * @param componentIndex\n   * @param externalPositionModules   List of external modules attached to each external position. Each module\n   *                                  maps to an external position\n   * @param externalPositions         Mapping of module => ExternalPosition struct for a given component\n   */\n  struct ComponentPosition {\n    int256 virtualUnit;\n    address[] externalPositionModules;\n    mapping(address => ExternalPosition) externalPositions;\n  }\n\n  /**\n   * A struct that stores a component's external position details including virtual unit and any\n   * auxiliary data.\n   *\n   * @param virtualUnit       Virtual value of a component's EXTERNAL position.\n   * @param data              Arbitrary data\n   */\n  struct ExternalPosition {\n    int256 virtualUnit;\n    bytes data;\n  }\n\n  /* ============ Functions ============ */\n\n  function addComponent(address _component) external;\n\n  function removeComponent(address _component) external;\n\n  function editDefaultPositionUnit(address _component, int256 _realUnit)\n    external;\n\n  function addExternalPositionModule(\n    address _component,\n    address _positionModule\n  ) external;\n\n  function removeExternalPositionModule(\n    address _component,\n    address _positionModule\n  ) external;\n\n  function editExternalPositionUnit(\n    address _component,\n    address _positionModule,\n    int256 _realUnit\n  ) external;\n\n  function editExternalPositionData(\n    address _component,\n    address _positionModule,\n    bytes calldata _data\n  ) external;\n\n  function invoke(\n    address _target,\n    uint256 _value,\n    bytes calldata _data\n  ) external returns (bytes memory);\n\n  function editPositionMultiplier(int256 _newMultiplier) external;\n\n  function mint(address _account, uint256 _quantity) external;\n\n  function burn(address _account, uint256 _quantity) external;\n\n  function lock() external;\n\n  function unlock() external;\n\n  function addModule(address _module) external;\n\n  function removeModule(address _module) external;\n\n  function initializeModule() external;\n\n  function setManager(address _manager) external;\n\n  function manager() external view returns (address);\n\n  function moduleStates(address _module) external view returns (ModuleState);\n\n  function getModules() external view returns (address[] memory);\n\n  function getDefaultPositionRealUnit(address _component)\n    external\n    view\n    returns (int256);\n\n  function getExternalPositionRealUnit(\n    address _component,\n    address _positionModule\n  ) external view returns (int256);\n\n  function getComponents() external view returns (address[] memory);\n\n  function getExternalPositionModules(address _component)\n    external\n    view\n    returns (address[] memory);\n\n  function getExternalPositionData(address _component, address _positionModule)\n    external\n    view\n    returns (bytes memory);\n\n  function isExternalPositionModule(address _component, address _module)\n    external\n    view\n    returns (bool);\n\n  function isComponent(address _component) external view returns (bool);\n\n  function positionMultiplier() external view returns (int256);\n\n  function getPositions() external view returns (Position[] memory);\n\n  function getTotalComponentRealUnits(address _component)\n    external\n    view\n    returns (int256);\n\n  function isInitializedModule(address _module) external view returns (bool);\n\n  function isPendingModule(address _module) external view returns (bool);\n\n  function isLocked() external view returns (bool);\n}\n"
    },
    "contracts/externals/interfaces/CurveContracts.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface CurveAddressProvider {\n  function get_registry() external view returns (address);\n}\n\ninterface CurveRegistry {\n  function get_pool_from_lp_token(address lp_token)\n    external\n    view\n    returns (address);\n}\n\ninterface CurveMetapool {\n  function get_virtual_price() external view returns (uint256);\n\n  function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amounts)\n    external\n    returns (uint256);\n\n  function add_liquidity(\n    uint256[2] calldata _amounts,\n    uint256 _min_mint_amounts,\n    address _receiver\n  ) external returns (uint256);\n\n  function remove_liquidity_one_coin(\n    uint256 amount,\n    int128 i,\n    uint256 min_underlying_amount\n  ) external returns (uint256);\n\n  function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n    external\n    view\n    returns (uint256);\n}\n\ninterface ThreeCrv is IERC20 {}\n\ninterface CrvLPToken is IERC20 {}\n"
    },
    "contracts/mocks/MockCurveThreepool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Docgen-SOLC: 0.8.0\npragma solidity ^0.8.0;\n\nimport \"./MockERC20.sol\";\n\ncontract MockCurveThreepool {\n  MockERC20 lpToken;\n  MockERC20 dai;\n  MockERC20 usdc;\n  MockERC20 usdt;\n\n  uint256 virtualPrice = 1e18;\n\n  uint256 withdrawalSlippageBps = 10;\n\n  uint256 BPS_DENOMINATOR = 10000;\n  MockERC20[] tokens;\n\n  event LiquidityAdded(uint256 lpToken, address account);\n  event EchoValues(uint256 amount);\n\n  constructor(\n    address lpToken_,\n    address dai_,\n    address usdc_,\n    address usdt_\n  ) {\n    lpToken = MockERC20(lpToken_);\n    dai = MockERC20(dai_);\n    usdc = MockERC20(usdc_);\n    usdt = MockERC20(usdt_);\n    tokens = [dai, usdc, usdt];\n  }\n\n  function coins(uint256 i) external view returns (address) {\n    return address(tokens[i]);\n  }\n\n  function get_virtual_price() external view returns (uint256) {\n    return virtualPrice;\n  }\n\n  function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amounts)\n    external\n    returns (uint256)\n  {\n    require(amounts[0] > 0, \"dai must be larger 0\");\n    require(min_mint_amounts == 0, \"min_mint_amounts must be 0\");\n    uint256 lpTokens;\n    for (uint8 i = 0; i < tokens.length; i++) {\n      tokens[i].transferFrom(msg.sender, address(this), amounts[i]);\n      lpToken.mint(msg.sender, amounts[i]);\n      lpTokens += amounts[i];\n    }\n    emit LiquidityAdded(lpTokens, msg.sender);\n    return lpTokens;\n  }\n\n  function remove_liquidity_one_coin(\n    uint256 _token_amount,\n    int128 i,\n    uint256 min_amount\n  ) external {\n    lpToken.transferFrom(msg.sender, address(this), _token_amount);\n\n    uint256 slippage = (_token_amount * withdrawalSlippageBps) / 10000;\n    uint256 transferOut = _token_amount - slippage;\n\n    uint128 idx = uint128(i);\n    tokens[idx].approve(address(this), transferOut);\n    tokens[idx].mint(address(this), transferOut);\n    tokens[idx].transferFrom(address(this), msg.sender, transferOut);\n  }\n\n  // Test helpers\n\n  function setVirtualPrice(uint256 virtualPrice_) external {\n    virtualPrice = virtualPrice_;\n  }\n\n  function setWithdrawalSlippage(uint256 withdrawalSlippageBps_) external {\n    withdrawalSlippageBps = withdrawalSlippageBps_;\n  }\n}\n"
    },
    "contracts/lbp/LBPManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ILBPFactory} from \"./interfaces/ILBPFactory.sol\";\nimport {ILBP} from \"./interfaces/ILBP.sol\";\nimport {IVault, JoinPoolRequest, IAsset, WeightedPoolExitKind, WeightedPoolJoinKind, ExitPoolRequest} from \"./interfaces/IVault.sol\";\n\n/**\n * @title LBP Manager\n * @notice This contract manages a Balancer Liquidity Bootstrapping Pool (LBP) so that only a DAO can deploy and shutdown an LBP. After the LBP is deployed, trading must be enabled. While only the DAO has permission to deploy, shutdown and unwind the LBP, anyone can permissionlessly enable trading after the configured start time. When the LBP is completed (via `withdrawFromPool()`), the total balance of the LBP tokens will be sent to the DAO treasury.\n */\ncontract LBPManager {\n  /* ========== STRUCTS ========== */\n\n  /**\n   * @title PoolConfiguration\n   * @param name LBP pool token name\n   * @param symbol LBP pool token symbol\n   * @param tokens the token pairs for the LBP (e.g. POP & USDC - addresses must be listed in ascending order)\n   * @param tokenAmounts the token amounts for the pair that will be transferred from the dao agent to this contract\n   * @param startWeights the starting weights for the token pairs, e.g. 99 * 10**16 / 1 * 10**16 [.99 ether / .01 ether]\n   * @param endWeights the ending weights for the token pairs, e.g. 50 * 10**16 / 50 * 10**16 [.5 ether / .5 ether]\n   * @param durationInSeconds how long the LBP should last in seconds. this determines how long it takes for the weights to reach the end weight\n   * @param swapFee fee to charge per trade. this fee is collected as part of the LBP proceeds\n   * @param owner address that is allowed to manage the LBP. it defaults to the deployed address of this contract\n   * @param swapEnabledOnStart determines wether trading can commence after LBP is deployed. defaults to false\n   * @param startTime the time that trading can commence for the LBP. the `enableTrading()` function will require that the start time is in the past before trading can be enabled\n   * @param deployed boolean set when LBP is deployed\n   * @param pauser address that may pause trading\n   */\n  struct PoolConfiguration {\n    string name;\n    string symbol;\n    IERC20[] tokens;\n    uint256[] tokenAmounts;\n    uint256[] startWeights;\n    uint256[] endWeights;\n    uint256 durationInSeconds;\n    uint256 swapFee;\n    address owner;\n    bool swapEnabledOnStart;\n    uint256 startTime;\n    bool deployed;\n    address pauser;\n  }\n\n  /**\n   * @title Balancer\n   * @dev addresses to deployed balancer contracts\n   * @param lbpFactory LiquidityBootstrapFactory address\n   * @param vault Balancer Vault address\n   */\n  struct Balancer {\n    ILBPFactory lbpFactory;\n    IVault vault;\n  }\n\n  /**\n   * @title DAO\n   * @dev DAO addresses\n   * @param agent the dao address that can interact with the contract\n   * @param treasury the dao treasury address where LBP proceeds will be sent\n   */\n  struct DAO {\n    address agent;\n    address treasury;\n  }\n\n  /* ========== STATE VARIABLES ========== */\n\n  /**\n   * @notice lbp deployed LBP address\n   */\n  ILBP public lbp;\n  Balancer public balancer;\n  PoolConfiguration public poolConfig;\n  DAO public dao;\n\n  /* ========== EVENTS ========== */\n\n  event SwapEnabled(bool enabled);\n  event CreatedPool(address poolAddress);\n  event JoinedPool(bytes32 poolID);\n  event ExitedPool(bytes32 poolID);\n\n  /* ========== CONSTRUCTOR ========== */\n\n  /**\n   * @param _balancer see struct Balancer - balancer contract addresses\n   * @param _name PoolConfiguration.name\n   * @param _symbol PoolConfiguration.symbol\n   * @param _tokens PoolConfiguration.tokens\n   * @param _tokenAmounts PoolConfiguration.tokenAmounts\n   * @param _startWeights PoolConfiguration.startWeights\n   * @param _endWeights PoolConfiguration.endWeights\n   * @param _swapFee PoolConfiguration.swapFee\n   * @param _durationInSeconds PoolConfiguration.durationInSeconds\n   * @param _startTime PoolConfiguration.startTime\n   * @param _dao see struct DAO - DAO addresses\n   */\n  constructor(\n    Balancer memory _balancer,\n    string memory _name,\n    string memory _symbol,\n    IERC20[] memory _tokens,\n    uint256[] memory _tokenAmounts,\n    uint256[] memory _startWeights,\n    uint256[] memory _endWeights,\n    uint256 _swapFee,\n    uint256 _durationInSeconds,\n    uint256 _startTime,\n    DAO memory _dao\n  ) {\n    balancer = _balancer;\n\n    require(_durationInSeconds > 1 hours && _durationInSeconds < 5 days, \"duration is out of bounds\");\n    require(_startTime > block.timestamp, \"start time must be in future\");\n\n    dao = _dao;\n\n    poolConfig = PoolConfiguration({\n      name: _name,\n      symbol: _symbol,\n      tokens: _tokens,\n      tokenAmounts: _tokenAmounts,\n      startWeights: _startWeights,\n      endWeights: _endWeights,\n      durationInSeconds: _durationInSeconds,\n      swapFee: _swapFee,\n      owner: address(this),\n      swapEnabledOnStart: false,\n      startTime: _startTime,\n      deployed: false,\n      pauser: msg.sender\n    });\n\n    _approveBalancerVaultAsSpender();\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @dev Will deploy a balancer LBP. Can only be called by DAO.agent address\n   * @notice This function requires that the DAO.agent has approved this address for spending pool tokens (e.g. POP & USDC). It will revert if the DAO.agent has not approved this contract for spending those tokens. The PoolConfiguration.tokenAmounts for the pool tokens will be transferred from the DAO.agent to this contract and forwarded to the LBP\n   */\n  function deployLBP() external {\n    require(msg.sender == dao.agent, \"Only DAO can call this\");\n    require(poolConfig.deployed != true, \"The pool has already been deployed\");\n    require(_hasTokensForPool(), \"Manager does not have enough pool tokens\");\n\n    poolConfig.deployed = true;\n\n    lbp = ILBP(\n      balancer.lbpFactory.create(\n        poolConfig.name,\n        poolConfig.symbol,\n        poolConfig.tokens,\n        poolConfig.startWeights,\n        poolConfig.swapFee,\n        poolConfig.owner,\n        poolConfig.swapEnabledOnStart\n      )\n    );\n\n    emit CreatedPool(address(lbp));\n\n    uint256 endtime = poolConfig.startTime + poolConfig.durationInSeconds;\n\n    lbp.updateWeightsGradually(poolConfig.startTime, endtime, poolConfig.endWeights);\n\n    _joinPool();\n  }\n\n  /**\n   * @notice Anyone can enable trading after the LBP has been deployed and the start time has been reached. Trading must be enabled for the pool to work.\n   */\n  function enableTrading() external {\n    require(poolConfig.deployed, \"Pool has not been deployed yet\");\n    require(poolConfig.startTime <= block.timestamp, \"Trading can not be enabled yet\");\n    lbp.setSwapEnabled(true);\n    emit SwapEnabled(true);\n  }\n\n  /**\n   * @notice The DAO.agent can call this function to shutdown and unwind the pool. The proceeds will be forwarded to the DAO.treasury\n   */\n  function withdrawFromPool() external {\n    require(poolConfig.deployed, \"Pool has not been deployed yet\");\n    require(msg.sender == dao.agent, \"not today, buddy\");\n\n    bytes32 poolId = lbp.getPoolId();\n\n    uint256[] memory minAmountsOut = new uint256[](poolConfig.tokens.length);\n    for (uint256 i; i < poolConfig.tokens.length; i++) {\n      minAmountsOut[i] = uint256(0);\n    }\n\n    lbp.setSwapEnabled(false);\n\n    ExitPoolRequest memory request = ExitPoolRequest({\n      assets: _convertERC20sToAssets(poolConfig.tokens),\n      minAmountsOut: minAmountsOut,\n      userData: abi.encode(uint256(WeightedPoolExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT), _getLPTokenBalance(poolId)),\n      toInternalBalance: false\n    });\n\n    balancer.vault.exitPool(poolId, address(this), dao.treasury, request);\n    emit ExitedPool(poolId);\n  }\n\n  /**\n   * @notice allows pauser to pause pool\n   */\n  function pause() external {\n    require(msg.sender == poolConfig.pauser, \"not allowed to pause trading\");\n    require(poolConfig.deployed, \"pool not yet deployed\");\n    require(lbp.getSwapEnabled() == true, \"pool must be unpaused\");\n    lbp.setSwapEnabled(false);\n  }\n\n  /**\n   * @notice allows pauser to unpause pool\n   */\n  function unpause() external {\n    require(msg.sender == poolConfig.pauser, \"not allowed to unpause trading\");\n    require(poolConfig.deployed, \"pool hasn't been deployed yet\");\n    require(lbp.getSwapEnabled() == false, \"swap is already disabled\");\n    lbp.setSwapEnabled(true);\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n  function _joinPool() internal {\n    uint256[] memory maxAmountsIn = new uint256[](poolConfig.tokens.length);\n    for (uint256 i; i < poolConfig.tokens.length; i++) {\n      maxAmountsIn[i] = type(uint256).max;\n    }\n\n    JoinPoolRequest memory request = JoinPoolRequest({\n      assets: _convertERC20sToAssets(poolConfig.tokens),\n      maxAmountsIn: maxAmountsIn,\n      userData: abi.encode(uint256(WeightedPoolJoinKind.INIT), poolConfig.tokenAmounts),\n      fromInternalBalance: false\n    });\n\n    balancer.vault.joinPool(lbp.getPoolId(), address(this), address(this), request);\n    emit JoinedPool(lbp.getPoolId());\n  }\n\n  function _approveBalancerVaultAsSpender() internal {\n    (IERC20 pop, IERC20 usdc) = _getPoolTokens();\n    pop.approve(address(balancer.vault), type(uint256).max);\n    usdc.approve(address(balancer.vault), type(uint256).max);\n  }\n\n  function _getLPTokenBalance(bytes32 poolId) internal returns (uint256) {\n    (address poolAddress, ) = balancer.vault.getPool(poolId);\n    IERC20 poolToken = IERC20(poolAddress);\n    return poolToken.balanceOf(address(this));\n  }\n\n  /**\n   * @dev This helper function is a fast and cheap way to convert between IERC20[] and IAsset[] types.\n   */\n  function _convertERC20sToAssets(IERC20[] memory tokens) internal pure returns (IAsset[] memory assets) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      assets := tokens\n    }\n  }\n\n  function _hasTokensForPool() internal view returns (bool) {\n    (IERC20 tokenA, IERC20 tokenB) = _getPoolTokens();\n\n    return\n      tokenA.balanceOf(address(this)) >= poolConfig.tokenAmounts[0] &&\n      tokenB.balanceOf(address(this)) >= poolConfig.tokenAmounts[1];\n  }\n\n  /* ========== VIEW FUNCTIONS ========== */\n  function _getPoolTokens() internal view returns (IERC20, IERC20) {\n    return (poolConfig.tokens[0], poolConfig.tokens[1]);\n  }\n}\n"
    },
    "contracts/lbp/interfaces/ILBPFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ILBPFactory {\n  function create(\n    string memory name,\n    string memory symbol,\n    IERC20[] memory tokens,\n    uint256[] memory weights,\n    uint256 swapFeePercentage,\n    address owner,\n    bool swapEnabledOnStart\n  ) external returns (address);\n}\n"
    },
    "contracts/lbp/interfaces/ILBP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ILBP {\n  function setSwapEnabled(bool swapEnabled) external;\n\n  function getSwapEnabled() external view returns (bool);\n\n  /**\n   * @dev Schedule a gradual weight change, from the current weights to the given\n   * endWeights, over startTime to endTime\n   */\n  function updateWeightsGradually(\n    uint256 startTime,\n    uint256 endTime,\n    uint256[] memory endWeights\n  ) external;\n\n  function getPoolId() external view returns (bytes32 poolID);\n}\n"
    },
    "contracts/lbp/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n  // solhint-disable-previous-line no-empty-blocks\n}\n\nenum PoolSpecialization {\n  GENERAL,\n  MINIMAL_SWAP_INFO,\n  TWO_TOKEN\n}\n\nenum WeightedPoolJoinKind {\n  INIT,\n  EXACT_TOKENS_IN_FOR_BPT_OUT,\n  TOKEN_IN_FOR_EXACT_BPT_OUT,\n  ALL_TOKENS_IN_FOR_EXACT_BPT_OUT\n}\n\nenum WeightedPoolExitKind {\n  EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n  EXACT_BPT_IN_FOR_TOKENS_OUT,\n  BPT_IN_FOR_EXACT_TOKENS_OUT,\n  MANAGEMENT_FEE_TOKENS_OUT\n}\n\nstruct JoinPoolRequest {\n  IAsset[] assets;\n  uint256[] maxAmountsIn;\n  bytes userData;\n  bool fromInternalBalance;\n}\nstruct ExitPoolRequest {\n  IAsset[] assets;\n  uint256[] minAmountsOut;\n  bytes userData;\n  bool toInternalBalance;\n}\n\ninterface IVault {\n  function setPaused(bool paused) external;\n\n  function getPool(bytes32 poolId) external returns (address, PoolSpecialization);\n\n  function joinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    JoinPoolRequest memory request\n  ) external payable;\n\n  function exitPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    ExitPoolRequest memory request\n  ) external payable;\n\n  function getPoolTokens(bytes32 poolId)\n    external\n    view\n    returns (\n      IERC20[] memory tokens,\n      uint256[] memory balances,\n      uint256 maxBlockNumber\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}